/* Penguin */

/*
 *         Copyright (C) Argonne National Laboratory
 *
 *   Argonne does not guarantee this software in any manner and is
 *   not responsible for any damages that may result from its use.
 *   Furthermore, Argonne does not provide any formal support for this
 *   software.  This is an experimental program.  This software
 *   or any part of it may be freely copied and redistributed,
 *   provided that this paragraph is included in each source file.
 *
 */

/*
 *  clause.c -- This file has routines associated with the clause data type.
 *
 */

#include "header.h"

#ifdef TURBO_C
#define CLAUSE_TAB_SIZE 100
#else
#ifdef THINK_C
#define CLAUSE_TAB_SIZE 100
#else
#define CLAUSE_TAB_SIZE 1000
#endif
#endif
    
/* hash table for accessing clauses by ID */
static struct clause_ptr *Clause_tab[CLAUSE_TAB_SIZE];

#ifndef ROO
/* In Glob for ROO. */
static int Int_clause_count;
/* # of clauses integrated; used for clause id */
static int Birth_time_count;
/* used for clause birth time */
#endif

/* back subsumed, demodulated put here, not deleted */
static struct clause *Hidden_clauses;
/* sent put here, later deleted */
static struct clause *Hidden_msgs;

/* array to mark mapped literals during subsumption */
#define MAX_LITS 100
static char Map_array[MAX_LITS];

#ifdef ROO

/*************
 *
 *    init_clause_tab_for_roo()
 *
 *    Insert dummy nodes so that all slaves will share table with master.
 *
 *************/

init_clause_tab_for_roo()
{
    int i;
    
    for (i=0; i<CLAUSE_TAB_SIZE; i++) {
        Clause_tab[i] = get_clause_ptr(); /* insert dummy node */
        Clause_tab[i]->c = NULL;
	}
}  /* init_clause_tab_for_roo */

#endif

/*************
 *
 *    int next_cl_num()
 *
 *    What is the next clause number?  Do not increment the count.
 *
 *************/

int next_cl_num()
{
#ifdef ROO
    return(Glob->Int_clause_count + 1);
#else
    return(Int_clause_count + 1);
#endif
}  /* next_cl_num */

/*************
 *
 *    int cl_integrate(c,ct,imt) -- integrate a clause
 *
 *    This routine integrates most subterms of the atoms. (Incoming clause must
 *    already have back pointers from literal to clause and atom to literal.)
 *
 *    The atoms are not shared, and arguments of positive equality literals
 *    are not shared.
 *
 *    A clause is integrated iff its ID is > 0.
 *
 *	Penguin adds two parameters:
 *	ct == IR iff c is an input clause read at this Penguin,
 *	ct == ND iff c is a new demodulator generated by new_demod(),
 *	ct == EC iff c is an empty clause generated by unit_conflict(),
 *	ct == IM iff c is an input message received at this Penguin,
 *	ct == 0 otherwise, i.e. any other clause.
 *	imt: if ct != IR, then imt == NONE, because it is not used,
 *	if ct == IR, then imt is one of IN_ALL_PENGUINS_*, where * may be
 *	S(os), U(sable), D(emodulators) and P(assive).
 *
 *	void in Otter, int in Penguin, as it returns TROUBLE/NO_TROUBLE.
 *
 *************/

int cl_integrate(c,ct,imt)
struct clause *c;
int ct, imt;
{
    struct literal *lit;
    struct term *atom;
    struct rel *r, *r1;
	int alloc_decided, i;		/* Variables added by Penguin */

    if (c->id != 0) {
fprintf(Fdout, "WARNING, cl_integrate, called with integrated clause: ");
	print_clause(Fdout, c);
	}
    else {
#ifdef ROO
	c->id = ++(Glob->Int_clause_count);
#else
		/* Penguin */

alloc_decided = 0;				/* default */

if (ct == ND)
	;
/* New demodulator: donothing, since c is a copy of an already integrated */
/* clause and it keeps the pid, lid, bt and dest of the original clause.  */
else if (ct == EC)
/* Empty clause: it sets pid and lid so that they will show in the printout */
/* of the proof. It also sets the birth time, although not strictly necessary.*/
	{
	c->pid = Whoami;
	c->lid = Penguins[Whoami]++;
	c->bt = ++Birth_time_count;
	}	/* end of if EC */
else if (ct == IR)
/* Input clause read at this Penguin: calls decide_allocation() to set pid, */
/* with second parameter set to 1 to say it is an input clause and third */
/* parameter set to dest == IN_ALL_PENGUINS_U/S/D/P to let decide_allocation()*/
/* know to which input list the clause belongs to; sets lid: 		*/
/* if c->pid == Whoami, Penguins[c->pid] is the count of clauses settled  */
/* at this Penguin, otherwise it is the count of the clauses sent by this */
/* Penguin to settle at the Penguin c->pid; 				*/
/* sets dest to IN_ALL_PENGUINS_U/S/D/P.				*/
/* Accordingly, c will belong to all Penguins, increase Penguins[i] for	*/
/* all i, otherwise only for the Penguin which owns c.			*/
	{
	decide_allocation(c,1,imt);
	c->lid = Penguins[c->pid];
	c->bt = 0;
	c->dest = imt;
if (eq_target(c) || reflexivity(c) || (Flags[OWN_IN_USABLE].val && c->dest==IN_ALL_PENGUINS_U) || (Flags[OWN_IN_SOS].val && c->dest==IN_ALL_PENGUINS_S))
		for (i = 0; i < No_of_nodes; i++)
			Penguins[i]++;
else Penguins[c->pid]++;
	}	/* end of if IR */
else if (ct == IM)
	{
if (eq_target(c) || reflexivity(c) || (Flags[OWN_IN_USABLE].val && c->dest==IN_ALL_PENGUINS_U) || (Flags[OWN_IN_SOS].val && c->dest==IN_ALL_PENGUINS_S))
		{
		c->pid = Whoami;
		if (c->lid >= Penguins[Whoami])
			Penguins[Whoami] = (c->lid) + 1;
		}
/* Input message: donothing, because pid, lid, bt and dest were set at the */
/* sender, except in case of reflexivity, equational targets and clauses in */
/* Usable/Sos when the Flags[OWN_IN_USABLE/SOS] is on, as these clauses	*/
/* belong to each Penguin.						*/
/* In these cases we don't call decide_allocation() to set c->pid, because */
/* since we have already determined the special conditions under which c->pid */
/* has to be reset to Whoami, it is useless to call decide_allocation() to */
/* repeat the same tests and set c->pid to Whoami.			*/
/* Also, if c belongs to all Penguins and its lid set by the Penguin which */
/* read the input turns out to be greater than Penguins[Whoami], the latter */
/* is updated.								*/
	}
else {	/* ct == 0: any other clause */
	if (c->pid == MAX_INT || eq_target(c))
		{
		decide_allocation(c,0,NONE);
		alloc_decided = 1;
		}
/* If the clause is a critical pair generated here or if it is an equational */
/* target, calls decide_allocation() to set pid, with second parameter set */
/* to 0 to say it is not an input clause and third parameter set to NONE */
/* because decide_allocation() does not use it on a non-input clause.	*/
/* The pid of an equational target is reset in any case to Whoami, 	*/
/* because equational targets belong where they are.			*/
if (c->pid==Whoami && (c->lid==MAX_INT || alloc_decided))
	{
	c->bt = ++Birth_time_count;
	c->dest = NONE;
	c->lid = Penguins[Whoami]++;
	}
else if (c->pid==Whoami && c->lid < Penguins[Whoami] && c->bt == MAX_INT)
	{
	c->bt = ++Birth_time_count;
	c->dest = NONE;
	}
/* If the clause belongs to this Penguin and it is			*/
/* either a received new settler settling down here, c->lid == MAX_INT,	*/
/* or a clause generated here and settling down here, c->lid == MAX_INT && */
/* alloc_decided,							*/
/* or an eq_target, brought in by an inference message, with c->lid !=	*/
/* MAX_INT, but alloc_decided == 1,
/* or a reduced resident, c->lid < Penguins[Whoami] && c->bt == MAX_INT,*/
/* whose bt has been reset to MAX_INT by back_demod() (see demod.c),	*/
/* sets its birth time and destination.					*/
/* For new settlers the lid is also set, while it is not touched for	*/
/* reduced residents.							*/
/* Resetting dest to NONE clears the clause c for broadcasting as	*/
/* inference message.							*/
else if (c->pid!=Whoami && c->lid==MAX_INT && alloc_decided)
	{
	c->dest = c->pid;
	Penguins[c->pid]++;
	}
/* If the clause has been generated at this Penguin, but decide_alloc() has */
/* decided that it settles down at c->pid, sets the dest accordingly and   */
/* increments the count of the clauses sent to the Penguin c->pid.	*/
	}	/* end of else */
		/* Penguin */

	c->id = ++Int_clause_count;

	/* Penguin */
if (ct != IR && alloc_decided && Flags[PRINT_ALLOC].val)
if (c->pid != Whoami)
	{
fprintf(Fdout,"Penguin%d decides that\n",Whoami);
print_clause(Fdout,c);
fprintf(Fdout,"will be sent as a new settler to Penguin%d.\n",c->pid); 
	}
else if (c->pid == Whoami)
	{
fprintf(Fdout,"Penguin%d decides that\n",Whoami);
print_clause(Fdout,c);
fprintf(Fdout,"will be a resident at Penguin%d itself.\n",Whoami); 
	}
	/* Penguin */
#endif
	if (cl_insert_tab(c) == TROUBLE)
		return(TROUBLE);
	lit = c->first_lit;
	while (lit != NULL) {
	    atom = lit->atom;
	    if (atom->varnum == POS_EQ || atom->varnum == LEX_DEP_DEMOD ||
		atom->varnum == CONDITIONAL_DEMOD) {
		/* do not share (condition), alpha, beta */
		r1 = atom->farg;
		while (r1 != NULL) {  /* for alpha and beta */
	if (bd_kludge_insert(r1->argval) == TROUBLE)
			return(TROUBLE);
	  /* put it where back demod can find it */
		    if (r1->argval->type == COMPLEX) {
			r = r1->argval->farg;
			while (r != NULL) {
			if (integrate_term(r->argval,&(r->argval)) == TROUBLE)
				return(TROUBLE);
			    r->argof = r1->argval;
			    r->nocc = r->argval->occ.rel;
			    r->argval->occ.rel = r;
			    r = r->narg;
			    }	/* end of while */
			}	/* end of if COMPLEX */
		    r1->argof = atom;
		    r1->argval->occ.rel = r1;
		    r1 = r1->narg;
		    }	/* end of while for alpha and beta */
		}	/* end of if POS_EQ or LEX_DEP_DEMOD or COND_DEMOD */
	    else if (atom->type == COMPLEX) {
		r = atom->farg;
		while (r != NULL) {
		if (integrate_term(r->argval,&(r->argval)) == TROUBLE)
			return(TROUBLE);
		    r->argof = atom;
		    r->nocc = r->argval->occ.rel;
		    r->argval->occ.rel = r;
		    r = r->narg;
		    }	/* end of while */
		}	/* end of else COMPLEX */
	    lit = lit->next_lit;
	    }	/* end of while */
	}	/* end of else */
return(NO_TROUBLE);
}  /* cl_integrate */

/*************
 *
 *    int cl_del_int(c) -- deallocate an integrated clause.
 *
 *	void in Otter, int in Penguin, as it returns TROUBLE/NO_TROUBLE
 *
 *************/

int cl_del_int(c)
struct clause *c;
{
    struct literal *lit, *plit;
    struct rel *r, *r2, *pr, *r1;
    struct term *atom;
    struct int_ptr *ip1, *ip2;

	if (c->id == 0)				/* Penguin */
	{
	output_stats(Fdout, 4);
	fprintf(Fderr, "ABEND, cl_del_int, non-integrated clause.\007\n");
	fprintf(Fdout, "ABEND, cl_del_int, non-integrated clause: ");
	print_clause(Fdout, c);
	return(TROUBLE);
	}
    lit = c->first_lit;
    while (lit != NULL) {
	atom = lit->atom;
	if (atom->varnum == POS_EQ || atom->varnum == LEX_DEP_DEMOD ||
		atom->varnum == CONDITIONAL_DEMOD) {
	    /* (condition), alpha, beta not shared */
	    r1 = atom->farg;
	    while (r1 != NULL) {  /* for alpha and beta */
		if (bd_kludge_delete(r1->argval) == TROUBLE)
			return(TROUBLE);
			 /* back demod kludge */
		r = r1->argval->farg;
		while (r != NULL) {
		    r2 = r->argval->occ.rel;
		    pr = NULL;
		    while (r2 != NULL && r2 != r) {
			pr = r2;
			r2 = r2->nocc;
			}	/* end of while */
		    if (r2 == NULL) {
			output_stats(Fdout, 4);
		fprintf(Fderr, "ABEND, cl_del_int, bad equality clause.\007\n");
		fprintf(Fdout, "ABEND, cl_del_int, bad equality clause: ");
			print_clause(Fdout, c);
			return(TROUBLE);
			}
		    if (pr == NULL)
			r->argval->occ.rel = r->nocc;
		    else
			pr->nocc = r->nocc;
		 if (r->argval->occ.rel == NULL)
			if (disintegrate_term(r->argval) == TROUBLE)
				return(TROUBLE);
		    pr = r;
		    r = r->narg;
		    free_rel(pr);
		    }	/* end of while */
		free_term(r1->argval);  /* alpha or beta */
		pr = r1;
		r1 = r1->narg;
		free_rel(pr);
		}	/* end of while for alpha and beta */
	    }	/* end of if type is POS_EQ, LEX_DEP or CONDITIONAL */
	else if (atom->type == COMPLEX) {
	    r = atom->farg;
	    while (r != NULL) {
		r2 = r->argval->occ.rel;
		pr = NULL;
		while (r2 != NULL && r2 != r) {
		    pr = r2;
		    r2 = r2->nocc;
		    }
		if (r2 == NULL) {
		    output_stats(Fdout, 4);
		    fprintf(Fderr, "ABEND, cl_del_int, bad clause.\007\n");
		    fprintf(Fdout, "ABEND, cl_del_int, bad clause: ");
		    print_clause(Fdout, c);
		    return(TROUBLE);
		    }
		if (pr == NULL)
		    r->argval->occ.rel = r->nocc;
		else
		    pr->nocc = r->nocc;
		if (r->argval->occ.rel == NULL)
		    if (disintegrate_term(r->argval) == TROUBLE)
			return(TROUBLE);
		pr = r;
		r = r->narg;
		free_rel(pr);
		}
	    }
	free_term(atom);
	plit = lit;
	lit = lit->next_lit;
	free_literal(plit);
	}
    ip1 = c->parents;
    while (ip1 != NULL) {
	ip2 = ip1;
	ip1 = ip1->next;
	free_int_ptr(ip2);
	}
    if (cl_delete_tab(c) == TROUBLE)
	return(TROUBLE);
    /* If there is other memory associated with clause, free it here */
    free_clause(c);
return(NO_TROUBLE);
}  /* cl_del_int */

/*************
 *
 *    cl_del_non(c) -- deallocate a nonintegrated clause.
 *
 *************/

void cl_del_non(c)
struct clause *c;
{
    struct literal *lit, *plit;
    struct int_ptr *ip1, *ip2;

    lit = c->first_lit;
    while (lit != NULL) {
	lit->atom->occ.lit = NULL;
	zap_term(lit->atom);
	plit = lit;
	lit = lit->next_lit;
	free_literal(plit);
	}
    ip1 = c->parents;
    while (ip1 != NULL) {
	ip2 = ip1;
	ip1 = ip1->next;
	free_int_ptr(ip2);
	}
    /* If there is other memory associated with clause, free it here */
    free_clause(c);
}  /* cl_del_non */

/*************
 *
 *    cl_int_chk(c) -- check structure of clause -- for debugging
 *
 *************/

void cl_int_chk(c)
struct clause *c;
{
    struct literal *lit;

    fprintf(Fdout,"checking clause, address:%x " , c);
    print_clause(Fdout, c);
    lit = c->first_lit;
    while (lit != NULL) {
fprintf(Fdout,"    literal, address:%x sign:%d type:%d; atom:", lit, lit->sign, lit->atom->varnum);
	print_term(Fdout, lit->atom); printf("\n");
fprintf(Fdout,"    cont_cl:%x, atom container:%x\n", lit->container, lit->atom->occ.lit);
	lit = lit->next_lit;
	}
}  /* cl_int_chk */

/*************
 *
 *    int read_cl_list(fp, errors_ptr, rcl)
 *
 *    Read clauses until EOF or the term `end_of_list' is reached.
 *
 *	struct list * in Otter, int in Penguin, as it returns TROUBLE/
 *	NO_TROUBLE. It returns the pointer to struct list through the
 *	parameter rcl.
 *
 *************/

int read_cl_list(fp, ep, rcl)
FILE *fp;
int *ep;
struct list **rcl;
{
    struct list *lst;
    struct clause *cl, *pcl;
    int rc;

	*rcl = NULL;				/* default */
    *ep = 0;
    if (get_list(&lst) == TROUBLE)
	return(TROUBLE);
    pcl = NULL;
    if (read_clause(fp, &rc, &cl) == TROUBLE)
	return(TROUBLE);
    while (rc == 0) {  /* while errors */
	(*ep)++;
    if (read_clause(fp, &rc, &cl) == TROUBLE)
	return(TROUBLE);
	}
    while (cl != NULL) {
	if (pcl == NULL)
	    lst->first_cl = cl;
	else
	    pcl->next_cl = cl;
	cl->prev_cl = pcl;
	cl->container = lst;
	pcl = cl;
    if (read_clause(fp, &rc, &cl) == TROUBLE)
	return(TROUBLE);
	while (rc == 0) {  /* while errors */
	    (*ep)++;
    if (read_clause(fp, &rc, &cl) == TROUBLE)
	return(TROUBLE);
	    }
	}
    lst->last_cl = pcl;
	*rcl = lst;
    return(NO_TROUBLE);
}  /* read_cl_list */
 
/*************
 *
 *    int read_clause(fp, retcd_ptr, rcla)
 *
 *	struct clause * in Otter, int in Penguin, as it returns TROUBLE/
 *	NO_TROUBLE. It returns the pointer to struct clause through the
 *	parameter rcla.
 *
 *************/

int read_clause(fp, rcp, rcla)
FILE *fp;
int *rcp;
struct clause **rcla;
{
    char buf[MAX_BUF];
    int p, go, sign, rc;
    struct term *t;
    struct clause *cl;
    struct literal *lit, *plit;

	*rcla = NULL;				/* default */
    rc = read_buf(fp, buf);
    if (rc == 0) {  /* error */
	*rcp = 0;
	return(NO_TROUBLE);
	}
    else if (buf[0] == '\0') {  /* ok. EOF */
	*rcp = 1;
	return(NO_TROUBLE);
	}
    else {
	if (get_clause(&cl) == TROUBLE)
		return(TROUBLE);
	plit = NULL;  /* prev lit */
	p = 0;
	skip_white(buf, &p);
	go = 1;
	while (go) {
	    sign = (buf[p] != '-');
	    if (sign == 0)
		p++;
	    if (str_atom(buf, &p, &rc, &t) == TROUBLE)
		return(TROUBLE);
	    if (rc == 0)
		sign = (sign ? 0 : 1);
	    if (t == NULL) {
		cl_del_non(cl);
		*rcp = 0;
		return(NO_TROUBLE);
		}
else if (t->type == NAME && str_ident(sn_to_str(t->sym_num),"end_of_list"))
		if (cl->first_lit == NULL) {
		    cl_del_non(cl);
		    free_term(t);
		    *rcp = 1;
		    return(NO_TROUBLE);
		    }
		else {
		    fprintf(Fdout, "ERROR, bad literal:\n");
		    print_error(Fdout, buf, p);
		    cl_del_non(cl);
		    free_term(t);
		    *rcp = 0;
		    return(NO_TROUBLE);
		    }
	    if (t->type == NAME && var_name(sn_to_str(t->sym_num))) {
		fprintf(Fdout, "ERROR, literal is variable:\n");
		print_error(Fdout, buf, p);
		cl_del_non(cl);
		free_term(t);
		*rcp = 0;
		return(NO_TROUBLE);
		}
	    if (get_literal(&lit) == TROUBLE)
		return(TROUBLE);
	    lit->atom = t;
	    lit->sign = sign;
	    lit->container = cl;  /* literal point up to clause */
	    t->occ.lit = lit;  /* atom point up to literal */
	    mark_literal(lit);  /* atoms have varnum > 0 */
if (lit->atom->varnum > 0 && (lit->atom->type == NAME || lit->atom->type == COMPLEX))
		set_to_predicate(lit->atom->sym_num);
/* Penguin: invokes set_to_predicate() to set to 1			*/
/* the predicate field in the symbol table element for lit->atom->sym_num */
	    if (plit == NULL)
		cl->first_lit = lit;
	    else
		plit->next_lit = lit;
	    plit = lit;
	    skip_white(buf, &p);
	    if (buf[p] == '|') {
		p++;
		skip_white(buf, &p);
		}
	    else if (buf[p] == '.')
		go = 0;
	    else {
		fprintf(Fdout, "ERROR, | or . expected in clause:\n");
		print_error(Fdout, buf, p);
		cl_del_non(cl);
		*rcp = 0;
		return(NO_TROUBLE);
		}
	    }
	if (set_vars_cl(cl)) {
	    for (lit = cl->first_lit; lit; lit = lit->next_lit) {
		if (contains_skolem_symbol(lit->atom)) {
	fprintf(Fdout, "\nERROR, input clause contains Skolem symbol:\n");
		    print_clause(Fdout, cl); printf("\n");
		    cl_del_non(cl);
		    *rcp = 0;
		    return(NO_TROUBLE);
		    }
		}
	    Stats[CL_INPUT]++;
	    *rcp = 1;
	*rcla = cl;
	    return(NO_TROUBLE);
	    }
	else {
fprintf(Fdout,"ERROR, too many variables in clause, max is %d:\n%s\n",MAX_VARS,buf);
	    cl_del_non(cl);
	    *rcp = 0;
	    return(NO_TROUBLE);
	    }
	}
}  /* read_clause */

/*************
 *
 *    int set_vars_cl(cl) -- decide which terms are variables
 *
 *************/

int set_vars_cl(cl)
struct clause *cl;
{
    struct literal *lit;
    char *varnames[MAX_VARS];
    int i;

    for (i=0; i<MAX_VARS; i++)
	varnames[i] = NULL;
    lit = cl->first_lit;
    while (lit != NULL) {
	if (set_vars_term(lit->atom, varnames))
	    lit = lit->next_lit;
	else
	    return(0);
	}
    return(1);
}

/*************
*
*	void print_ids(fp,clause)		Penguin only
*
*	Print < pid lid id bt > of a clause.
*
**************/

void print_ids(fp,cl)
FILE *fp;
struct clause *cl;

{
if (cl != NULL)
{
fprintf(fp,"< ");
if (cl->pid == MAX_INT)
	fprintf(fp,"_ ");
else fprintf(fp,"%d ",cl->pid);
if (cl->lid == MAX_INT)
	fprintf(fp,"_ ");
else fprintf(fp,"%d ",cl->lid);
fprintf(fp,"%d ",cl->id);
if (cl->bt == MAX_INT)
	fprintf(fp,"_ >");
else fprintf(fp,"%d >",cl->bt);
}
}	/* print_ids() */

/*************
 *
 *    print_clause(fp, clause)
 *
 *************/

void print_clause(fp, cl)
FILE *fp;
struct clause *cl;
{
    struct literal *lit;
    struct int_ptr *ip;

if (cl != NULL)
{
	print_ids(fp,cl);
    fprintf(fp," [");
    if (cl->parents != NULL) {
	ip = cl->parents;
	while (ip != NULL) {
	    switch (ip->i) {
		case BINARY_RES_RULE  : fprintf(fp, "binary"); break;
		case HYPER_RES_RULE   : fprintf(fp, "hyper"); break;
		case NEG_HYPER_RES_RULE   : fprintf(fp, "neg_hyper"); break;
		case UR_RES_RULE      : fprintf(fp, "ur"); break;
		case PARA_INTO_RULE   : fprintf(fp, "para_into"); break;
		case PARA_FROM_RULE   : fprintf(fp, "para_from"); break;
		case FACTOR_RULE      : fprintf(fp, "factor"); break;
		case NEW_DEMOD_RULE   : fprintf(fp, "new_demod"); break;
		case BACK_DEMOD_RULE  : fprintf(fp, "back_demod"); break;
		case DEMOD_RULE       : fprintf(fp, "demod"); break;
		case UNIT_DEL_RULE    : fprintf(fp, "unit_del"); break;
		case NEW_FUNCTION_RULE: fprintf(fp, "new_function"); break;
		case FLIP_EQ_RULE     : fprintf(fp, "flip_eq"); break;
		case LINKED_UR_RES_RULE : fprintf(fp, "linked_ur_res"); break;
		case EVAL_RULE        : fprintf(fp, "eval"); break;
		default               : fprintf(fp, "%d", ip->i); break;
		}
	    ip = ip->next;
	    if (ip != NULL)
		fprintf(fp, ",");
	    }
	}
    fprintf(fp, "] ");
    lit = cl->first_lit;
    while (lit != NULL) {
	if (lit->sign == 0 && lit->atom->sym_num != Eq_sym_num)
	    fprintf(fp, "-");
	print_term(fp, lit->atom);
	lit = lit->next_lit;
	if (lit != NULL)
	    fprintf(fp, " | ");
	}
    fprintf(fp, ".\n");
}
}  /* print_clause */

/*************
 *
 *    int read_clause_msg(buffer,retcd_ptr,rclam)		Penguin only
 *
 *	Penguin: it returns TROUBLE/NO_TROUBLE.
 *	It returns the pointer to struct clause through the parameter rclam.
 *
 *************/

int read_clause_msg(buf,rcp,rclam)
char *buf;
int *rcp;
struct clause **rclam;
{
    int p, go, sign, rc;
    struct term *t;
    struct clause *cl;
    struct literal *lit, *plit;

	*rclam = NULL;				/* default */
    if (buf[0] == '\0') {  /* ok. EOF */
	*rcp = 1;
	return(NO_TROUBLE);
	}
    else {
	if (get_clause(&cl) == TROUBLE)
		return(TROUBLE);
	plit = NULL;  /* prev lit */
	p = 0;
	skip_white(buf, &p);
	go = 1;
	while (go) {
	    sign = (buf[p] != '-');
	    if (sign == 0)
		p++;
	    if (str_atom(buf, &p, &rc, &t) == TROUBLE)
		return(TROUBLE);
	    if (rc == 0)
		sign = (sign ? 0 : 1);
	    if (t == NULL) {
		cl_del_non(cl);
		*rcp = 0;
		return(NO_TROUBLE);
		}
else if (t->type == NAME && str_ident(sn_to_str(t->sym_num),"end_of_list"))
		if (cl->first_lit == NULL) {
		    cl_del_non(cl);
		    free_term(t);
		    *rcp = 1;
		    return(NO_TROUBLE);
		    }
		else {
		    fprintf(Fdout, "ERROR, bad literal:\n");
		    print_error(Fdout, buf, p);
		    cl_del_non(cl);
		    free_term(t);
		    *rcp = 0;
		    return(NO_TROUBLE);
		    }
	    if (t->type == NAME && var_name(sn_to_str(t->sym_num))) {
		fprintf(Fdout, "ERROR, literal is variable:\n");
		print_error(Fdout, buf, p);
		cl_del_non(cl);
		free_term(t);
		*rcp = 0;
		return(NO_TROUBLE);
		}
	    if (get_literal(&lit) == TROUBLE)
		return(TROUBLE);
	    lit->atom = t;
	    lit->sign = sign;
	    lit->container = cl;  /* literal point up to clause */
	    t->occ.lit = lit;  /* atom point up to literal */
	    mark_literal(lit);  /* atoms have varnum > 0 */
if (lit->atom->varnum > 0 && (lit->atom->type == NAME || lit->atom->type == COMPLEX))
		set_to_predicate(lit->atom->sym_num);
/* Penguin: invokes set_to_predicate() to set to 1			*/
/* the predicate field in the symbol table element for lit->atom->sym_num */
	    if (plit == NULL)
		cl->first_lit = lit;
	    else
		plit->next_lit = lit;
	    plit = lit;
	    skip_white(buf, &p);
	    if (buf[p] == '|') {
		p++;
		skip_white(buf, &p);
		}
	    else if (buf[p] == '.')
		go = 0;
	    else {
		fprintf(Fdout, "ERROR, | or . expected in clause:\n");
		print_error(Fdout, buf, p);
		cl_del_non(cl);
		*rcp = 0;
		return(NO_TROUBLE);
		}
	    }
	if (set_vars_cl(cl)) {
	    Stats[CL_INPUT]++;
	    *rcp = 1;
	*rclam = cl;
	    return(NO_TROUBLE);
	    }
	else {
fprintf(Fdout,"ERROR, too many variables in clause, max is %d:\n%s\n",MAX_VARS,buf);
	    cl_del_non(cl);
	    *rcp = 0;
	    return(NO_TROUBLE);
	    }
	}
}  /* read_clause_msg */

/*************
 *
 *    str_print_clause(buf,ip,clause)		Penguin only
 *
 *************/

void str_print_clause(buf,ip,cl)
char *buf;
int *ip;
struct clause *cl;
{
    struct literal *lit;

if (cl == NULL || cl->first_lit == NULL)
	{
	str_copy("     ",buf+*ip);
	*ip += 5;
	}
else	{ /* clause not null */
    lit = cl->first_lit;
    while (lit != NULL) {
	if (lit->sign == 0 && lit->atom->sym_num != Eq_sym_num)
		buf[(*ip)++] = '-';
	str_print_term(buf,ip,lit->atom);
	lit = lit->next_lit;
	if (lit != NULL)
		{
		str_copy(" | ",buf+*ip);
		*ip += 3;
		}
	}
}	/* end of else clause not null */
}  /* str_print_clause */

/*************
*
*	int sprint_clause(s,cl)		Penguin only
*
**************/

int sprint_clause(s,cl)
char *s;
struct clause *cl;
{
int i;

i = 0;
str_print_clause(s,&i,cl);
s[i++] = '.';
s[i] = '\0';
return(i);

}	/* sprint_clause() */

/*************
 *
 *    p_clause(clause)
 *
 *************/

void p_clause(cl)
struct clause *cl;
{
    print_clause(Fdout, cl);
}  /* p_clause */

/*************
 *
 *    print_cl_list(fp, lst)
 *
 *************/

void print_cl_list(fp, lst)
FILE *fp;
struct list *lst;
{
    struct clause *cl;

    if (lst == NULL)
	fprintf(fp, "(list nil)\n");
    else {
	cl = lst->first_cl;
	while (cl != NULL) {
	    print_clause(fp, cl);
	    cl = cl->next_cl;
	    }
	fprintf(fp, "end_of_list.\n");
	}
}  /* print_cl_list */

/*************
 *
 *    cl_merge(cl) -- merge identical literals (keep leftmost occurrence)
 *
 *************/

void cl_merge(c)
struct clause *c;
{
    struct literal *l1, *l2, *l_prev;

    l1 = c->first_lit;
    while (l1 != NULL) {
	l2 = l1->next_lit;
	l_prev = l1;
	while (l2 != NULL)
	    if (l1->sign == l2->sign && term_ident(l1->atom, l2->atom)) {
		l_prev->next_lit = l2->next_lit;
		l2->atom->occ.lit = NULL;
		zap_term(l2->atom);
		free_literal(l2);
		l2 = l_prev->next_lit;
		}
	    else {
		l_prev = l2;
		l2 = l2->next_lit;
		}
	l1 = l1->next_lit;
	}
}  /* cl_merge */

/*************
 *
 *     int tautology(c) -- Is clause c a tautology?
 *
 *************/

int tautology(c)
struct clause *c;
{
    struct literal *l1, *l2;
    int taut;

    taut = 0;
    l1 = c->first_lit;
    while (l1 != NULL && taut == 0) {
	l2 = l1->next_lit;
	while (l2 != NULL && taut == 0) {
	    taut = (l1->sign != l2->sign && term_ident(l1->atom, l2->atom));
	    l2 = l2->next_lit;
	    }
	l1 = l1->next_lit;
	}
    return(taut);
}  /* tautology */

/*************
 *
 *    int size_ancestor_bag(c)
 *
 *    Count the bag (not set) of ancestors.
 *
 *************/

int size_ancestor_bag(c)
struct clause *c;
{
    struct int_ptr *ip;
    int count, id;
    struct clause *parent;

    count = 0;
    for (ip = c->parents; ip != NULL; ip = ip->next) {
	id = ip->i;
	if (id > 0) {
	    parent = cl_find(id);
	    if (parent != NULL)
		count = count + 1 + size_ancestor_bag(parent);
	    }
	}
    return(count);
}  /* size_ancestor_bag */

/*************
 *
 *    int size_ancestor_set(c, sas)
 *
 *    Count the set of ancestors.
 *
 *	Penguin: it returns TROUBLE/NO_TROUBLE and the number of ancestors
 *	through tha parameter sas.
 *
 *************/

int size_ancestor_set(c, sas)
struct clause *c;
int *sas;
{
    struct clause_ptr *cp1, *cp2;
    int count;

    cp1 = NULL;
    if (get_ancestors(c, &cp1) == TROUBLE)
	return(TROUBLE);

    for (count = -1; cp1 != NULL; count++) {
	cp2 = cp1;
	cp1 = cp1->next;
	free_clause_ptr(cp2);
	}

	*sas = count;
    return(NO_TROUBLE);
}  /* size_ancestor_set */

/*************
 *
 *    int proof_length(c, pl)
 *
 *    Return length of proof.  If demod_history is clear, demodulation
 *    steps are not counted.  "new_demod" steps are not counted.
 *	Penguin: it returns TROUBLE/NO_TROUBLE and the length through
 *	the parameter pl.
 *
 *************/

int proof_length(c, pl)
struct clause *c;
int *pl;
{
    struct clause_ptr *cp1, *cp2;
    int count;

    cp1 = NULL;
    if (get_ancestors(c, &cp1) == TROUBLE)
	return(TROUBLE);

    for (count = 0; cp1 != NULL; ) {
        if (cp1->c->parents && cp1->c->parents->i != NEW_DEMOD_RULE)
	    count++;
	cp2 = cp1;
	cp1 = cp1->next;
	free_clause_ptr(cp2);
	}

	*pl = count;
    return(NO_TROUBLE);
}  /* proof_length */

/*************
 *
 *    int subsume(c, d, suby) -- does clause c subsume clause d?
 *
 *	Penguin: it returns TROUBLE/NO_TROUBLE and 0/1 through the
 *	parameter suby.
 *
 *************/

int subsume(c,d,suby)
struct clause *c;
struct clause *d;
int *suby;
{
    struct context *s;
    struct trail *tr;
    int subsumed;

    if (get_context(&s) == TROUBLE)
	return(TROUBLE);
    tr = NULL;
   if (map_rest(c, d, s, &tr, &subsumed) == TROUBLE)
	return(TROUBLE);
    if (subsumed)
	clear_subst_1(tr);
    free_context(s);
	*suby = subsumed;
    return(NO_TROUBLE);
}  /* subsume */

/*************
 *
 *    int map_rest(c, d, s, trp, mr) 
 *	 map rest of literals - for subsumption
 *
 *	Penguin: it returns TROUBLE/NO_TROUBLE and 0/1 through the
 *	parameter mr.
 *
 *************/

int map_rest(c, d, s, trp, mr)
struct clause *c;
struct clause *d;
struct context *s;
struct trail **trp;
int *mr;
{
    struct literal *c_lit, *d_lit;
    struct term *c_atom, *d_atom;
    struct trail *t_pos;
    int subsumed, i;
	int mok, mpr;

	*mr = 0; 				/* default */

    /* get the first unmarked literal */
    c_lit = c->first_lit;
    i = 0;
    while (c_lit != NULL && Map_array[i] == 1) {
	c_lit = c_lit->next_lit;
	i++;
	}

    if (c_lit == NULL)
	{
	*mr = 1;
	return(NO_TROUBLE);  /* all lits of c mapped, so c subsumes d */
	}
    else if (c_lit->atom->varnum == ANSWER) {   /* if answer literal, skip it */
	c_atom = c_lit->atom;
	Map_array[i] = 1;      /* mark as mapped */
	if (map_rest(c, d, s, trp, &subsumed) == TROUBLE)
		return(TROUBLE);
	Map_array[i] = 0;      /* remove mark */
	*mr = subsumed;
	return(NO_TROUBLE);
	}
    else {
	c_atom = c_lit->atom;
	Map_array[i] = 1;      /* mark as mapped */
	d_lit = d->first_lit;
	subsumed = 0;
	while (d_lit != NULL && subsumed == 0)
	{
	    d_atom = d_lit->atom;
	    t_pos = *trp;  /* save position in trail in case of failure */
	    if (c_lit->sign == d_lit->sign)
		{	/* if pre-conditions for trying match */
		if (match(c_atom, s, d_atom, trp, &mok) == TROUBLE)
			return(TROUBLE);
		if (mok == 1)
		{	/* if match */
		if (map_rest(c, d, s, trp, &mpr) == TROUBLE)
			return(TROUBLE);
		if (mpr == 1)
		    subsumed = 1;
		else {
		    clear_subst_2(*trp, t_pos);
		    *trp = t_pos;
		    }
		}	/* end of if match */
		}	/* end of if pre-conditions for trying match */
	    d_lit = d_lit->next_lit;
	    }	/* end of while */
	Map_array[i] = 0;      /* remove mark */
	*mr = subsumed;
	return(NO_TROUBLE);
	}
}  /* map_rest */

/*************
 *
 *    int anc_subsume(c, d, asuby)
 *
 *    We already know that c subsumes d.  Check if d subsumes c and 
 *    ancestors(c) <= ancestors(d).
 *
 *	Penguin: it returns TROUBLE/NO_TROUBLE and 0/1 through the 
 *	the parameter asuby.
 *
 *************/

int anc_subsume(c,d,asuby)
struct clause *c;
struct clause *d;
int *asuby;
{
int subi;
int sasc, sasd;

	*asuby = 0;				/* default */

    if (subsume(d,c,&subi) == TROUBLE)
	return(TROUBLE);

	if (subi)
	{
	if (size_ancestor_set(c, &sasc) == TROUBLE)
		return(TROUBLE);
	if (size_ancestor_set(d, &sasd) == TROUBLE)
		return(TROUBLE);
	*asuby = (sasc <= sasd);
	return(NO_TROUBLE);
	}
    else
	{
	*asuby = 1;
	return(NO_TROUBLE);
	}
}  /* anc_subsume */

/*************
 *
 *    int forward_subsume(d,input,msg_del,subsumer)
 *
 *    Attempt to find a clause that subsumes d.
 *    *struct clause in Otter, as it returns the subsuming clause,
 *    int in Penguin, as it returns TROUBLE/NO_TROUBLE. It returns the
 *    subsuming clause through the parameter subsumer.
 *    Penguin adds the parameter msg_del, which is set to point to 1
 *    only if d and *subsumer are variants and d should subsume *subsumer
 *    rather than *subsumer subsume d, because of distributed subsumption.
 *    Penguin also adds the parameter input saying whether d is an input
 *    clause or not. If it is, the check for variants of distributed
 *    subsumption does not apply.
 *
 *************/

int forward_subsume(d,input,msg_del,subsumer)
struct clause *d;
int input;
int *msg_del;
struct clause **subsumer;
{
    int subsumed;
    struct literal *d_lit;
    struct clause *c;
    struct term *c_atom, *d_atom;
    struct context *s;
    struct trail *tr;
    struct is_tree *is_db;
    struct fsub_pos *pos;
    struct fpa_head **fpa_db;
    struct fpa_tree *ut;
    int d_size, c_size, factor, i;
    struct literal *lit;
	int vsub, mok;

    subsumed = 0;
    *msg_del = 0;
    *subsumer = NULL;				/* default */
/* *msg_del is set to 0, to mean that as a default d is subsumed by the */
/* clause c returned by the function.					*/
    if (get_context(&s) == TROUBLE)
	return(TROUBLE);

    factor = Flags[FACTOR].val;
    if (factor)  /* if factor don't let long clauses subsume short */
	d_size = num_literals(d);

    if (Flags[FOR_SUB_FPA].val == 0) {  /* if `is' indexing */
	d_lit = d->first_lit;

	while (d_lit != NULL && subsumed == 0) {
	    /* Is_pos_lits and Is_neg_lits are global variables */
	    is_db = d_lit->sign ? Is_pos_lits : Is_neg_lits;
	    if (fs_retrieve(d_lit->atom, s, is_db, &pos, &c_atom) == TROUBLE)
			return(TROUBLE);
	    while (c_atom != NULL && subsumed == 0) {
		c = c_atom->occ.lit->container;
		c_size = num_literals(c);
		if (c_size > MAX_LITS) {
		    output_stats(Fdout, 4);
		    fprintf(Fderr, "ABEND, forward_subsume, MAX_LITS.\007\n");
		    fprintf(Fdout, "ABEND, forward_subsume, MAX_LITS.\n");
		    return(TROUBLE);
		    }
		if (factor == 0 || c_size <= d_size) {
		    for (i = 0, lit = c->first_lit;
                         lit->atom != c_atom; 
                         i++, lit = lit->next_lit);  /* empty body */
	            Map_array[i] = 1;      /* mark as mapped*/
		    tr = NULL;
		    if (map_rest(c, d, s, &tr, &subsumed) == TROUBLE)
			return(TROUBLE);
	            Map_array[i] = 0;      /* remove mark */
		    }

		if (subsumed)	/* c subsumes d */
		{
if (!input && ((c->pid!=Whoami && c->pid!=MAX_INT) || (d->pid!=Whoami && d->pid!=MAX_INT)))
/* Handling variants in Penguin: it applies if 				 */
/* d is not an input clause read by this Penguin (input) and at least one */
/* of the two clauses belongs to another node.				*/
/* New clauses which have not yet been integrated have infinity, 	*/
/* implemented as MAX_INT, as pid, lid and bt, and NONE as dest.	*/
/* It should never be the case that c has pid equal to MAX_INT, because	*/
/* here we are trying to forward subsume d by a clause c which has	*/
/* been already indexed and integrated.	However, c->lid may be MAX_INT if */
/* c is a new settler destinated to another node and the flag post_process_ */
/* ns_before_send is on. In such a case c has smaller bt than d.	*/
		{
		renumber_vars(d);
	if (subsume(d,c,&vsub) == TROUBLE)
		return(TROUBLE);
		if (vsub)	/* c and d are variants */
if (d->bt < c->bt || (d->bt==c->bt && (d->lid < c->lid || (d->lid==c->lid && d->pid < c->pid))))
			*msg_del = 1;	
/* d should subsume c rather than vice versa. 				*/
/* Clauses are compared first by birth-time, then by lid and then by pid. */
/* Two clauses may have the same lid only if they come from 		*/
/* different nodes and then we compare the pid's.			*/
/* Referring to the treatment of distributed subsumption in my thesis:	*/
/* we don't need inference-time, because we never compare two raw clauses, */
/* since each raw clause is pre-processed right after generation;	*/
/* the lid of an inference message implements in a sense its reception time. */
		} /* end of handling of variants in Penguin */
	else /* handling variants in Otter */
		if (Flags[ANCESTOR_SUBSUME].val) {
		    renumber_vars(d);
		    if (anc_subsume(c, d, &subsumed) == TROUBLE)
				return(TROUBLE);
		    if (!subsumed)
			Stats[CL_NOT_ANC_SUBSUMED]++;
		    }
	}	/* end of if subsumed */

/*		back to Otter's code			*/

		if (subsumed == 0)
		{
if (fs_retrieve((struct term *) NULL, s, is_db, &pos, &c_atom) == TROUBLE)
		return(TROUBLE);
		}
		else {
		    clear_subst_1(tr);
		    canc_fs_pos(pos, s);
		    }
		}	/* end of while */
	    d_lit = d_lit->next_lit;
	    }	/* end of while on d_lit */
	}	/* end of if 'is' indexing */
    else {  /* fpa indexing */

	d_lit = d->first_lit;
	while (d_lit != NULL && subsumed == 0) {
	    fpa_db = (d_lit->sign ? Fpa_pos_lits : Fpa_neg_lits);
	    d_atom = d_lit->atom;
if (build_tree(d_atom,MORE_GEN,Parms[FPA_LITERALS].val,fpa_db,&ut) == TROUBLE)
		return(TROUBLE);
	    c_atom = next_term(ut, 0);
	    while (c_atom != NULL && subsumed == 0) {
		tr = NULL;
	        c = c_atom->occ.lit->container;
		c_size = num_literals(c);
		if (c_size > MAX_LITS) {
		    output_stats(Fdout, 4);
		    fprintf(Fderr, "ABEND, forward_subsume, MAX_LITS.\007\n");
		    fprintf(Fdout, "ABEND, forward_subsume, MAX_LITS.\n");
		    return(TROUBLE);
		    }
		if (factor == 0 || c_size <= d_size)
		{	/* if pre-conditions for trying match */
		if (match(c_atom, s, d_atom, &tr, &mok) == TROUBLE)
			return(TROUBLE);
		if (mok)
		{	/* if match */
		    for (i = 0, lit = c->first_lit;
			 lit->atom != c_atom; 
			 i++, lit = lit->next_lit);  /* empty body */
		    Map_array[i] = 1;      /* mark as mapped*/
		    if (map_rest(c, d, s, &tr, &subsumed) == TROUBLE)
			return(TROUBLE);
		    Map_array[i] = 0;      /* remove mark */
		    clear_subst_1(tr);
		}	/* end of if match */
		}	/* end of if pre-conditions for trying match */

		if (subsumed)	/* c subsumes d */
		{
if (!input && ((c->pid!=Whoami && c->pid!=MAX_INT) || (d->pid!=Whoami && d->pid!=MAX_INT)))
/* Handling variants in Penguin: it applies if 				 */
/* d is not an input clause read by this Penguin (input) and at least one */
/* of the two clauses belongs to another node.				*/
/* New clauses which have not yet been integrated have infinity, 	*/
/* implemented as MAX_INT, as lid and pid and NONE as dest.		*/
/* It should never be the case that c has pid equal to MAX_INT, because	*/
/* here we are trying to forward subsume d by a clause c which has	*/
/* been already indexed and integrated.	However, c->lid may be MAX_INT if */
/* c is a new settler destinated to another node and the flag post_process_ */
/* ns_before_send is on. In such a case c has smaller bt than d.	*/
		{	/* handling of variants in Penguin */
		renumber_vars(d);
	if (subsume(d, c, &vsub) == TROUBLE)
		return(TROUBLE);
		if (vsub)	/* c and d are variants */
if (d->bt < c->bt || (d->bt==c->bt && (d->lid < c->lid || (d->lid==c->lid && d->pid < c->pid))))
			*msg_del = 1;	
/* d should subsume c rather than vice versa. 				*/
/* Clauses are compared first by birth-time, then by lid and then by pid. */
/* Two clauses may have the same lid only if they come from 		*/
/* different nodes and then we compare the pid's.			*/
/* Referring to the treatment of distributed subsumption in my thesis:	*/
/* we don't need inference-time, because we never compare two raw clauses, */
/* since each raw clause is pre-processed right after generation;	*/
/* the lid of an inference message implements in a sense its reception time. */
		} /* end of handling of variants in Penguin */
	else /* handling variants in Otter */
		if (Flags[ANCESTOR_SUBSUME].val) {
		    renumber_vars(d);
		    if (anc_subsume(c, d, &subsumed) == TROUBLE)
			return(TROUBLE);
		    if (!subsumed)
			Stats[CL_NOT_ANC_SUBSUMED]++;
		    }	/* end of handling variants in Otter */
	}	/* end of if subsume */

/*		back to Otter's code			*/

		if (subsumed == 0)
		    c_atom = next_term(ut, 0);
		else
		    zap_prop_tree(ut);
		}	/* end of while */
	    d_lit = d_lit->next_lit;
	    }	/* end of while */    
	}	/* end of fpa-indexing */
    free_context(s);
    if (subsumed)
	*subsumer = c;
	return(NO_TROUBLE);
}  /* forward_subsume */

/*************
 *
 *    int back_subsume(c,input,msg,sub_cls)
 *
 *    Get the list of clauses subsumed by c.
 *	struct clause_ptr * in Otter, int in Penguin, as it returns TROUBLE/
 *	NO_TROUBLE. It returns the list of subsumed clauses through the
 *	parameter sub_cls.
 *	Penguin adds the parameter msg, which is set to point to a
 *	clause such that msg is a variant of c and it is smaller than c
 *	in the ordering for distributed subsumption.
 *	The clause msg in this special case is not
 *	inserted in *sub_cls.
 *	Penguin also adds the parameter input, since distributed
 *	subsumption of variants is not necessary if c is an
 *	input clause.
 *
 *************/

int back_subsume(c,input,msg,sub_cls)
struct clause *c, **msg;
int input;
struct clause_ptr **sub_cls;
{
    int subsumed, c_size, factor, i;
    struct literal *c_lit;
    struct clause *d, *v;
    struct clause_ptr *subsumed_clauses;
    struct term *c_atom, *d_atom;
    struct context *s;
    struct fpa_tree *ut;
    struct trail *tr;
	int vsub, mok;

	*msg = NULL;		/* default is NULL */
	*sub_cls = NULL;	/* default */
	v = NULL;

    factor = Flags[FACTOR].val;
    
    c_size = num_literals(c);

    if (c_size > MAX_LITS) {
	output_stats(Fdout, 4);
	fprintf(Fderr, "ABEND, back_subsume, MAX_LITS.\007\n");
	fprintf(Fdout, "ABEND, back_subsume, MAX_LITS.\n");
	return(TROUBLE);
	}
    
    if (get_context(&s) == TROUBLE)
	return(TROUBLE);
    c_lit = c->first_lit;
    /* get first non-answer literal */
    i = 0;
    while (c_lit != NULL && c_lit->atom->varnum == ANSWER) {
	c_lit = c_lit->next_lit;
	i++;
	}

    if (c_lit == NULL) {
	fprintf(Fdout, "\nNOTE: back_subsume called with empty clause.\n");
	return(NO_TROUBLE);
	}

    c_atom = c_lit->atom;
if (build_tree(c_atom,INSTANCE,Parms[FPA_LITERALS].val,
		c_lit->sign ? Fpa_pos_lits : Fpa_neg_lits,&ut) == TROUBLE)
		return(TROUBLE);
	/* Fpa_pos_lits and Fpa_neg_lits are global variables */

    subsumed_clauses = NULL;
    d_atom = next_term(ut, 0);
    while (d_atom != NULL)
	{
	d = d_atom->occ.lit->container;
	tr = NULL;
	if (c != d && (factor == 0 || c_size <= num_literals(d)))
	{	/* if pre-conditions for trying match */
		if (match(c_atom, s, d_atom, &tr, &mok) == TROUBLE)
			return(TROUBLE);
		if (mok)
		{	/* if match */
	    Map_array[i] = 1;  /* mark as mapped */
	    if (map_rest(c, d, s, &tr, &subsumed) == TROUBLE)
		return(TROUBLE);
	    Map_array[i] = 0;    /* remove mark */
	    clear_subst_1(tr);
		if (subsumed)	/* c subsumes d */
if (!input && ((c->pid!=Whoami && c->pid!=MAX_INT) || (d->pid!=Whoami && d->pid!=MAX_INT)))
/* Handling variants in Penguin: it applies if 				 */
/* c is not an input clause read by this Penguin (input) and at least one */
/* of the two clauses belongs to another node.		 		*/
/* Remark that renumber_vars(d) is not invoked here in back_subsume.	*/
/* The reason is that renumber_vars() applies to non-integrated clauses	*/
/* and therefore it may be applied to the clause being subsumed in	*/
/* forward_subsume(), which is being pre_processed and has not been	*/
/* integrated yet, but not here in back_subsume, where both clauses	*/
/* are assumed to have been already integrated.				*/
/* For this reason the check pid!=MAX_INT is redundant, but we do it 	*/
/* nonetheless.								*/
		{
		if (subsume(d, c, &vsub) == TROUBLE)
			return(TROUBLE);
		if (vsub)	/* c and d are variants */
if (d->bt < c->bt || (d->bt==c->bt && (d->lid < c->lid || (d->lid==c->lid && d->pid < c->pid))))
			v = d;

/* It saves the clause which should not be subsumed by c.		*/
/* Rather, d should subsume c. 						*/
/* Clauses are compared first by birth-time, then by lid and then by pid. */
/* Two clauses may have the same lid only if they come from 		*/
/* different nodes and then we compare the pid's.			*/
/* New clauses which have not yet been integrated have infinity, 	*/
/* implemented as MAX_INT, as lid.					*/
		}	/* end of handling variants in Penguin. */

/* Back to Otter's code.					*/

	    if (subsumed && d != v)
		if (insert_clause(d, &subsumed_clauses) == TROUBLE)
			return(TROUBLE);
	    }	/* end of if match */
	}	/* end of if pre-conditions for trying match */
	d_atom = next_term(ut, 0);
	}	/* end of while */
    free_context(s);
	*sub_cls = subsumed_clauses;
	*msg = v;
    return(NO_TROUBLE);
}  /* back_subsume() */

/*************
 *
 *    int unit_conflict(c,dcp)
 *
 *	Search for unit conflict.
 *	struct clause_ptr * in Otter, as it returns empty clause if found,
 *   	return NULL if not found.
 *	int in Penguin, as it returns TROUBLE/NO_TROUBLE. It returns the
 *	pointer to struct clause_ptr through the parameter dcp.
 *
 *    IT IS ASSUMED THAT c IS A UNIT CLAUSE!!
 *
 *************/

int unit_conflict(c,dcp)
struct clause *c;
struct clause_ptr **dcp;
{
    struct clause *d, *e;
    struct fpa_tree *ut;
    struct term *f_atom;
    struct literal *lit;
    int go, mp, ec;
    struct context *c1, *c2;
    struct trail *tr;
    struct clause_ptr *cp_return, *cp_prev, *cp_curr;
	int uok;

	*dcp = NULL;				/* default */
    if (get_context(&c1) == TROUBLE)
	return(TROUBLE);
    c1->multiplier = 0;
    if (get_context(&c2) == TROUBLE)
	return(TROUBLE);
    c2->multiplier = 1;
    lit = c->first_lit;
    while (lit->atom->varnum == ANSWER)  /* skip answer literals */
	lit = lit->next_lit;
    if (build_tree(lit->atom,UNIFY,Parms[FPA_LITERALS].val, 
		    lit->sign ? Fpa_neg_lits : Fpa_pos_lits,&ut) == TROUBLE)
		return(TROUBLE);
    f_atom = next_term(ut, 0);
    go = 1;
    cp_return = cp_prev = NULL;
    while (go && f_atom) {
	tr = NULL;
	d = f_atom->occ.lit->container;
	if (num_literals(d) == 1)
	{	/* if pre-conditions to try unify() */
	if (unify(lit->atom, c1, f_atom, c2, &tr, &uok) == TROUBLE)
		return(TROUBLE);
	if (uok)
	{	/* if unify() succeeds */
	    if (build_bin_res(lit->atom,c1,f_atom,c2,&e) == TROUBLE)
		return(TROUBLE);
	    clear_subst_1(tr);
	    cl_merge(e);  /* answer literals */
	    if (get_clause_ptr(&cp_curr) == TROUBLE)
		return(TROUBLE);
	    cp_curr->c = e;
	    if (cp_prev)
		cp_prev->next = cp_curr;
	    else
		cp_return = cp_curr;
	    cp_prev = cp_curr;

	    mp = Parms[MAX_PROOFS].val;

if (d->container == Passive && mp > 1 && target(d) == ANS_TARGET) /* Penguin */
	d->type = SOLVED_TARGET;
         
	    ec = ++Stats[EMPTY_CLAUSES];

	    if (mp == 1)		/* Penguin */
		{
		if (ec >= 1)
			/* do not look for more proofs */
			go = 0;
		}
	    else if (mp > 1)
		{
		if (ex_ans_target(Passive))
			{
			if (ec >= mp && all_solved_ans_target(Passive))
			/* do not look for more proofs */
				go = 0;
			}
		else
			{
			if (ec >= mp)
			/* do not look for more proofs */
				go = 0;
			}
		}
/* See pheader.h for explanation of why the detection that no more proofs */
/* are needed is different in Penguin from Otter.			*/

	    }	/* end of if unify() succeeds */
	}	/* end of if pre-conditions to try unify() */
	if (go)
	    f_atom = next_term(ut, 0);
	else
	    zap_prop_tree(ut);
	}	/* end of while */
    free_context(c1);
    free_context(c2);
	*dcp = cp_return;
    return(NO_TROUBLE);
}  /* unit_conflict() */
	
/*************
 *
 *    int pos_clause(c)  --  Is this a positive clause (excluding answer lits) ?
 *
 *************/

int pos_clause(c)
struct clause *c;
{
    struct literal *lit;

    lit = c->first_lit;
    while (lit != NULL)
	if (lit->sign == 0 && lit->atom->varnum != ANSWER)
	    return(0);  /* fail because found negative non-anser literal */
	else
	    lit = lit->next_lit;
    return(1);
}  /* pos_clause */

/*************
 *
 *    int all_pos_but_lit(c,li)			Penguin
 *	Is this a positive clause but for the given literal li
 *	(excluding answer lits) ?
 *
 *************/

int all_pos_but_lit(c,li)
struct clause *c;
struct literal *li;
{
    struct literal *lit;

    lit = c->first_lit;
    while (lit != NULL)
	if (lit->sign == 0 && lit->atom->varnum != ANSWER && lit != li)
	    return(0);  /* fail because found negative non-anser literal */
	else
	    lit = lit->next_lit;
    return(1);
}  /* all_pos_but_lit */

/*************
 *
 *    int neg_clause(c)  --  Is this a negative clause (excluding answer lits) ?
 *
 *************/

int neg_clause(c)
struct clause *c;
{
    struct literal *lit;

    lit = c->first_lit;
    while (lit != NULL)
	if (lit->sign && lit->atom->varnum != ANSWER)
	    return(0);  /* fail because found positive non-answer literal */
	else
	    lit = lit->next_lit;
    return(1);
}  /* neg_clause */

/*************
 *
 *    int num_literals(c)  --  How many literals (excluding answer literals)?
 *
 *************/

int num_literals(c)
struct clause *c;
{
    int i;
    struct literal *lit;

    i = 0;
    lit = c->first_lit;
    while (lit != NULL) {
	if (lit->atom->varnum != ANSWER)  /* if not answer literal */
	    i++;
	lit = lit->next_lit;
	}
    return(i);
}  /* num_literals */

/*************
 *
 *    int unit_clause(c)  -- Is it a unit clause?
 *
 *************/

int unit_clause(c)
struct clause *c;
{
    return(num_literals(c) == 1);
}  /* unit_clause */

/*************
*
*	int reflexivity(c) -- Is it the reflexivity axiom x=x ?
*
*	Added by Penguin.
*
**************/

int reflexivity(c)
struct clause *c;
{
struct rel *r1, *r2;
struct term *a, *lhs, *rhs;

if (c == NULL)
	return(0);
else if (c->first_lit == NULL)
	return(0);
else if (num_literals(c) > 1)
	return(0);
else {
	a = c->first_lit->atom;
	if (a->varnum != POS_EQ)
	return(0);
	else {
		r1 = a->farg;
		r2 = r1->narg;
		lhs = r1->argval;
		rhs = r2->argval;
		if (lhs->type != VARIABLE)
		return(0);
		else if (rhs->type != VARIABLE)
		return(0);
		else return(lhs->varnum == rhs->varnum);
		}
	}
}	/* reflexivity() */

/*************
 *
 *	int target(c)				Added by Penguin.
 *
 *	It detects three types of targets.
 *
 *	If Flags[KNUTH_BENDIX}.val, the problem is purely equational
 *	and a negated equation is a target of type KB_TARGET.
 *	This corresponds to targets in the form
 *		forall x s = t
 *	which becomes
 *		s^ != t^
 *	where all variables are replaced by Skolem constants.
 *
 *	If KB_TARGET is off, we return KB_TARGET only if the two sides
 *	of the negated equation are ground.
 *
 *	Otherwise, if the clause is made only of negated equations and
 *	answer literals, provided Flags[UR_RES].val is 0, it is a target
 *	of type EXT_EQ_TARGET.
 *	This corresponds to targets in the form
 *		exists x  s_1 = t_1 & ... & s_n = t_n & -$answer(x)
 *	which becomes
 *		s_1 != t_1 | ... | s_n != t_n | $answer(x).
 *	The provision that Flags[UR_RES].val is off is added because there
 *	are problems, where the goal has indeed this form, but the axioms
 *	are not unit equations, but disjunctions of equations and UR_RES is
 *	used to solve the problem. These problems are not equational and we
 *	need to use the target like for general FOL+= problems.
 *
 *	Otherwise, if there is an answer literal, then it is an ANS_TARGET.
 *	This corresponds to targets in the form
 *		exists x  L_1 & ... & L_n & -$answer(x)
 *	which becomes
 *		-L_1 | ... | -L_n | $answer(x),
 *	where the L_i are not necessarily positive.
 *
 *************/

int target(c)
struct clause *c;
{
struct term *a;
struct literal *lit;
int ans, not_ans_not_neg_eq;
struct term *lhs, *rhs;

if (c == NULL)
	return(0);
else if (c->first_lit == NULL)
	return(0);
else {	/* not null clause */

a = c->first_lit->atom;

if (unit_clause(c) && a->varnum == NEG_EQ)
	{
	if (Flags[KNUTH_BENDIX].val)
		return(KB_TARGET);

	lhs = a->farg->argval;
	rhs = a->farg->narg->argval;
	if (ground(lhs) && ground(rhs))
		return(KB_TARGET);
	}

ans = 0;
not_ans_not_neg_eq = 0;

    lit = c->first_lit;
    while (lit != NULL)
	{
	 if (lit->atom->varnum != ANSWER && lit->atom->varnum != NEG_EQ)
		not_ans_not_neg_eq = 1;
	 else if (lit->atom->varnum == ANSWER)
		ans = 1;	/* found an answer literal */
	lit = lit->next_lit;
	}

if (ans == 1 && not_ans_not_neg_eq == 0 && Flags[UR_RES].val == 0)
	return(EXT_EQ_TARGET);
else if (ans == 1)
	return(ANS_TARGET);
else return(0);
}	/* end of not null clause */
}	/* target() */

/***************
*
*	int eq_target(c)			Penguin only
*
***************/

int eq_target(c)
struct clause *c;
{
int tt;

tt = target(c);

if (tt == KB_TARGET || tt == EXT_EQ_TARGET)
	return(1);
else return(0);
}	/* eq_target() */

/***************
*
*	int ex_ans_target(l)			Penguin only
*
*	It returns 1 if the list l contains at least an ANS_TARGET.
*	It is called with l == Passive by unit_conflict().
*
****************/

int ex_ans_target(l)
struct list *l;
{
struct clause *c;

if (l == NULL)
	return(0);
else	{
c = l->first_cl;
while (c != NULL)
	{
	if (target(c) == ANS_TARGET)
		return(1);
	c = c->next_cl;
	}
return(0);
}
}	/* ex_ans_target() */

/***************
*
*	int all_solved_ans_target(l)			Penguin only
*
*	It returns 1 if all the ANS_TARGETS in the list l have the field
*	type set to SOLVED_TARGET.
*	The field type is set to SOLVED_TARGET if the clause has
*	generated an empty clause by unit_conflict().
*	It is called after ex_ans_target(l) has returned 1.
*	It is called with l == Passive by unit_conflict().
*
****************/

int all_solved_ans_target(l)
struct list *l;
{
struct clause *c;

if (l == NULL)
	return(1);	/* trivially true */
else	{
c = l->first_cl;
while (c != NULL)
	{
	if (target(c) == ANS_TARGET && c->type != SOLVED_TARGET)
		return(0);
	c = c->next_cl;
	}
return(1);
	}
}	/* all_solved_ans_target() */

/*************
 *
 *    append_cl(lst, cl)
 *
 *************/

void append_cl(l, c)
struct list *l;
struct clause *c;
{
    c->next_cl = NULL;
    c->prev_cl = l->last_cl;

    if (l->first_cl == NULL)
	l->first_cl = c;
    else
	l->last_cl->next_cl = c;
    l->last_cl = c;
    c->container = l;
}  /* append_cl */

/*************
 *
 *    prepend_cl(lst, cl)
 *
 *************/

void prepend_cl(l, c)
struct list *l;
struct clause *c;
{
    c->prev_cl = NULL;
    c->next_cl = l->first_cl;
    if (l->last_cl == NULL)
	l->last_cl = c;
    else
	l->first_cl->prev_cl = c;
    l->first_cl = c;
    c->container = l;
}  /* prepend_cl */

/*************
 *
 *    insert_before_cl(c, c_new)
 *
 *************/

void insert_before_cl(c, c_new)
struct clause *c;
struct clause *c_new;
{
    struct list *l;

    l = c->container;

    c_new->next_cl = c;
    c_new->prev_cl = c->prev_cl;
    c->prev_cl = c_new;
    if (c_new->prev_cl == NULL)
	l->first_cl = c_new;
    else
	c_new->prev_cl->next_cl = c_new;

    c_new->container = l;

}  /* insert_before_cl */

/*************
 *
 *    insert_after_cl(c, c_new)
 *
 *************/

void insert_after_cl(c, c_new)
struct clause *c;
struct clause *c_new;
{
    struct list *l;

    l = c->container;

    c_new->prev_cl = c;
    c_new->next_cl = c->next_cl;
    c->next_cl = c_new;
    if (c_new->next_cl == NULL)
	l->last_cl = c_new;
    else
	c_new->next_cl->prev_cl = c_new;

    c_new->container = l;

}  /* insert_after_cl */

/*************
 *
 *    rem_from_list(c)
 *
 *************/

void rem_from_list(c)
struct clause *c;
{
    struct clause *p, *n;

    p = c->prev_cl;
    n = c->next_cl;
    if (n == NULL)
	c->container->last_cl = p; 
    else
	n->prev_cl = p;
    if (p == NULL)
	c->container->first_cl = n;
    else
	p->next_cl = n;
    c->container = NULL;
    c->prev_cl = NULL;
    c->next_cl = NULL;
}  /* rem_from_list */

/*************
 *
 *    int insert_clause(clause, *clause_ptr)
 *
 *    If not already there, insert clause into list of clause pointers.
 *
 *	void in Otter, int in Penguin, as it returns TROUBLE/NO_TROUBLE.
 *
 *************/

int insert_clause(c, cpp)
struct clause *c;
struct clause_ptr **cpp;
{
    struct clause_ptr *curr, *prev, *new;

    curr = *cpp;
    prev = NULL;
    while (curr != NULL && curr->c->id > c->id) {
	prev = curr;
	curr = curr->next;
	}
    if (curr == NULL || curr->c->id != c->id) {
	if (get_clause_ptr(&new) == TROUBLE)
		return(TROUBLE);
	new->c = c;
	new->next = curr;
	if (prev != NULL) 
	    prev->next = new;
	else
	    *cpp = new;
	}
return(NO_TROUBLE);
}  /* insert_clause */

/*************
 *
 *    int weight_cl(c, wt_index)  --  Weigh a clause.
 *
 *    Also weigh answer lits, which have default weight 0.
 *
 *************/

int weight_cl(c, wt_index)
struct clause *c;
struct is_tree *wt_index;
{
    int w, neg_weight;
    struct literal *lit;

    neg_weight = Parms[NEG_WEIGHT].val;
    w = 0;
    lit = c->first_lit;
    while (lit != NULL) {
	w += weight(lit->atom, wt_index);
	if (lit->atom->varnum != ANSWER && lit->sign == 0)
	    w += neg_weight;
	lit = lit->next_lit;
	}
    return(w);
}  /* weight_cl */

/*************
 *
 *    hide_clause(c) --  c must be integrated
 *
 *    Clauses can be hidden instead of deallocated so that they can
 *    be printed later on (mostly so that a child can know its parent).
 *
 *************/

void hide_clause(c)
struct clause *c;
{
    c->next_cl = Hidden_clauses;
    Hidden_clauses = c;
}  /* hide_clause */

/*************
 *
 *    int del_hidden_clauses() -- deallocate all hidden clauses
 *
 *	void in Otter, int in Penguin, as it returns TROUBLE/NO_TROUBLE.
 *
*************/

int del_hidden_clauses()
{
    struct clause *c;

    while (Hidden_clauses != NULL) {
	c = Hidden_clauses;
	Hidden_clauses = Hidden_clauses->next_cl;
	if (cl_del_int(c) == TROUBLE)
		return(TROUBLE);
	}
return(NO_TROUBLE);
}  /* del_hidden_clauses */

/*************
 *
 *    hide_msg(c)	c not necessarily integrated	Penguin only
 *
 *	Same as hide_clause(). A separate list is used for messages
 *	deleted from Outbound_msgs when they are sent, because the
 *	default for Flags[REALLY_DELETE_CLAUSES].val is 0, whereas the
 *	default for Flags[REALLY_DELETE_MSGS].val is 1.
 *
 *************/

void hide_msg(c)
struct clause *c;
{
    c->next_cl = Hidden_msgs;
    Hidden_msgs = c;
}  /* hide_msg */

/*************
 *
 *    int del_hidden_msgs() -- deallocate all hidden msgs	Penguin only
 *
 *	It returns TROUBLE/NO_TROUBLE.
 *
 *************/

int del_hidden_msgs()
{
    struct clause *c;

    while (Hidden_msgs != NULL) {
	c = Hidden_msgs;
	Hidden_msgs = Hidden_msgs->next_cl;
	if (c->id == 0)			/* not integrated */
		cl_del_non(c);
	else {				/* integrated */
	if (cl_del_int(c) == TROUBLE)
		return(TROUBLE);
		}
	}
return(NO_TROUBLE);
/* Comment: hidden clauses are guaranteed to be integrated. Not so hidden */
/* messages. If an hidden message carried a new settler, then it is */
/* integrated. The reason is that when we send a new settler in		*/
/* cl_integrate(), we append to Outbound_msgs the clause itself.	*/
/* New settlers destinated to other Penguins are also integrated,	*/
/* so that if check_for_proof(), invoked 				*/
/* by pre_process(), finds a proof before the new settler is sent and if */
/* the new settler contributes to the proof, check_for_proof() can retrieve */
/* the new settler by id.						*/
/* If an hidden message carried an input clause or an inference message	*/
/* then it is not integrated, because when we send an input clause in	*/
/* cl_integrate() or an inference message in infer(), we append to	*/
/* Outbound_msgs a copy of the clause and the copy is not integrated.	*/
}  /* del_hidden_msgs */

/***************
*
*	int send_clause(c)	Penguin only
*
***************/

int send_clause(c)
struct clause *c;
{
struct clause *d, *e;
int input_msg;

if (c != NULL && is_other_penguin_up() && Flags[STAND_ALONE].val == 0)
/* Before proceeding, we check that some				*/
/* other Penguin but this one is up, because if all other Penguins are	*/
/* in trouble, we do not send.						*/
	{
if (c->dest == c->pid)
/* c is being routed as a new settler: c->dest is equal to c->pid, the	*/
/* Penguin c is supposed to belong to. No need to make a copy, we send c */
/* itself.								*/
	{
if (Flags[POST_PROC_NS_BEFORE_SEND].val)
	{
/* New settler were temporarily kept for post_processing, i.e. appended */
/* to Sos and indexed. When send_clause() is called from within the main */
/* loop, the new settler c has been already removed from Sos, but we still */
/* need to un_index it before appending it to Outbound_msgs.		*/
	if (Flags[DYNAMIC_DEMOD].val)
		{
/* If these flags are on, the new settler c may have been made into a */
/* new demodulator e and therefore we need to un_index, rem_from_list	*/
/* and hide such e. 							*/
		e = cl_find(c->id + 1);
if (e != NULL && e->pid == c->pid && e->lid == c->lid && e->container == Demodulators)
			if (un_index_rem_and_hide(e) == TROUBLE)
				return(TROUBLE);
		}
	if (un_index_lits_all(c) == TROUBLE)
		return(TROUBLE);
	}	/* end of if new settlers were temporarily kept */
	append_cl(Outbound_msgs,c);
	Stats[OUTBOUND_MSGS_SIZE]++;
	if (Flags[PRINT_SENT].val)
		{
		fprintf(Fdout,"** SENT: ");
		print_clause(Fdout,c);
		fflush(Fdout);
		}
	}	/* end of if new settler */
else {	/* inference message */
if (c->dest == ALL_PENGUINS)	/* non-input inference message */
	input_msg = 0;
else if (c->dest==IN_ALL_PENGUINS_U || c->dest==IN_ALL_PENGUINS_S || c->dest== IN_ALL_PENGUINS_D || c->dest== IN_ALL_PENGUINS_P)
	/* input inference message */
	input_msg = 1;
else {
	fprintf(Fdout,"WARNING: found clause to be sent but no destination.\n");
	fprintf(Fdout,"Destination set automatically to ALL_PENGUINS.\n");
	print_clause(Fdout,c);
	}
/* A copy of c is sent as an inference message and c itself 		*/
/* is kept at this Penguin.						*/
	if (cl_copy(c,&d) == TROUBLE)
		return(TROUBLE);
	append_cl(Outbound_msgs,d);
	Stats[OUTBOUND_MSGS_SIZE]++;
if (Flags[PRINT_SENT].val && (!input_msg || Flags[PROCESS_INPUT].val))
		{
		fprintf(Fdout,"** SENT: ");
		print_clause(Fdout,d);
		}
	}
}	/* end of if not NULL and other Penguin is up. */
/* Clauses appended to Outbound_msgs will be hidden when sent by get_mesg() */
/* and deallocated when del_hidden_msgs() is invoked by post_proc_all().    */

return(NO_TROUBLE);
}	/* send_clause() */

/*************
 *
 *    int cl_copy(c, clc)
 *
 *    Do not copy neither the list of parents nor the id.
 *
 *	Penguin: since c->pid and c->lid are copied, c->dest is copied
 *	also, because same pid and same lid means same global identifier
 *	and therefore we keep record in the destination field of where
 *	the clause was sent, e.g. whether it has been broadcasted already
 *	or not.
 *
 *	struct clause * in Otter, int in Penguin, as it returns TROUBLE/
 *	NO_TROUBLE. It returns the pointer to struct clause through the
 *	parameter clc.
 *
 *************/

int cl_copy(c, clc)
struct clause *c;
struct clause **clc;
{
    struct clause *d;
    struct literal *l, *l1, *l2;
	struct term *tempatom;

	*clc = NULL;				/* default */
    if (get_clause(&d) == TROUBLE)
	return(TROUBLE);
    d->type = c->type;
    d->pid = c->pid;			/* Penguin */
    d->lid = c->lid;			/* Penguin */
    d->bt = c->bt;			/* Penguin */
    d->dest = c->dest;			/* Penguin */
    l = c->first_lit;
    l2 = NULL;
    while (l != NULL) {
	if (get_literal(&l1) == TROUBLE)
		return(TROUBLE);
	l1->target = l->target;
	l1->container = d;
	l1->sign = l->sign;
	if (copy_term(l->atom, &tempatom) == TROUBLE)
		return(TROUBLE);
	l1->atom = tempatom;
	remove_var_syms(l1->atom);  /* nullify variable symbols (if present) */
	l1->atom->occ.lit = l1;
	if (l2 == NULL)
	    d->first_lit = l1;
	else
	    l2->next_lit = l1;
	l2 = l1;
	l = l->next_lit;
	}
	*clc = d;
    return(NO_TROUBLE);
}  /* cl_copy */

/*************
 *
 *    remove_var_syms(t)
 *
 *    Variable terms normally do not have sym_nums.  This
 *    routine removes any that are present.
 *
 *************/

void remove_var_syms(t)
struct term *t;
{
    struct rel *r;

    if (t->type == VARIABLE)
        t->sym_num = 0;
    else if (t->type == COMPLEX)
	for (r = t->farg; r != NULL; r = r->narg)
	    remove_var_syms(r->argval);
}  /* remove_var_syms */

/*************
 *
 *    int cl_insert_tab(c)
 *
 *	void in Otter, int in Penguin, as it returns TROUBLE/NO_TROUBLE.
 *
 *************/

int cl_insert_tab(c)
struct clause *c;
{
    struct clause_ptr *cp1, *cp2, *cp3;
    int hashval, id;

    id = c->id;
    hashval = id % CLAUSE_TAB_SIZE;
    cp1 = Clause_tab[hashval];
    cp2 = NULL;

#ifdef ROO
    cp2 = cp1;
    cp1 = cp1->next;  /* skip dummy node */
#endif

    /* keep the chains ordered--increasing id */

    while (cp1 != NULL && cp1->c->id < id) {
	cp2 = cp1;
	cp1 = cp1->next;
	}
    if (cp1 != NULL && cp1->c->id == id) {
	output_stats(Fdout, 4);
	fprintf(Fderr, "ABEND, cl_insert_tab, clause already there.\007\n");
	fprintf(Fdout, "ABEND, cl_insert_tab, clause already there: ");
	print_clause(Fdout, c);
	return(TROUBLE);
	}
    else {
	if (get_clause_ptr(&cp3) == TROUBLE)
		return(TROUBLE);
	cp3->c = c;
	cp3->next = cp1;
	if (cp2 == NULL) 
	    Clause_tab[hashval] = cp3;
	else
	    cp2->next = cp3;
	}
return(NO_TROUBLE);
}  /* cl_insert_tab */

/*************
 *
 *    int cl_delete_tab(c)
 *
 *	void in Otter, int in Penguin, as it returns TROUBLE/NO_TROUBLE.
 *
 *************/

int cl_delete_tab(c)
struct clause *c;
{
    struct clause_ptr *cp1, *cp2;
    int hashval, id;

    id = c->id;
    hashval = id % CLAUSE_TAB_SIZE;
    cp1 = Clause_tab[hashval];
    cp2 = NULL;

#ifdef ROO
    cp2 = cp1;
    cp1 = cp1->next;  /* skip dummy node */
#endif

    /* chains are ordered--increasing id */

    while (cp1 != NULL && cp1->c->id < id) {
	cp2 = cp1;
	cp1 = cp1->next;
	}
    if (cp1 == NULL || cp1->c->id != id) {
	output_stats(Fdout, 4);
	fprintf(Fderr, "ABEND, cl_delete_tab, clause not found.\007\n");
	fprintf(Fdout, "ABEND, cl_delete_tab, clause not found: ");
	print_clause(Fdout, c);
	return(TROUBLE);
	}
    else {
	if (cp2 == NULL) 
	    Clause_tab[hashval] = cp1->next;
	else
	    cp2->next = cp1->next;
	free_clause_ptr(cp1);
	}
return(NO_TROUBLE);
}  /* cl_delete_tab */

/*************
 *
 *    struct clause *cl_find(id)
 *
 *************/

struct clause *cl_find(id)
int id;
{
    struct clause_ptr *cp1;
    int hashval;

    hashval = id % CLAUSE_TAB_SIZE;
    cp1 = Clause_tab[hashval];

#ifdef ROO
    cp1 = cp1->next;  /* skip dummy node */
#endif

    /* lists are ordered--increasing id */

    while (cp1 != NULL && cp1->c->id < id)
	cp1 = cp1->next;
    if (cp1 == NULL || cp1->c->id != id)
	return(NULL);
    else
	return(cp1->c);
}  /* cl_find */

/*************
 *
 *    sort_lits(c)  --  sort literals
 *
 *************/

void sort_lits(c)
struct clause *c;
{
    struct literal *slits, *prev, *curr, *next, *inst;
    int sign, sym_num;

    /* this is an insertion sort */

    /* 1. negative before positive; */
    /* 2. non-answer literals before answer literals; */
    /* 3. lower symbol numbers first */

    slits = c->first_lit;
    if (slits == NULL)
	return;  /* c is empty clause */
    else {
	inst = slits->next_lit;
	slits->next_lit = NULL;
	while(inst != NULL) {
	    prev = NULL;
	    sign = inst->sign;
	    sym_num = inst->atom->sym_num;
	    if (inst->atom->varnum == ANSWER) {
		sym_num += 5000;
		}
	    curr = slits;
	    while (curr != NULL && 
		   (sign > curr->sign || 
		    (sign == curr->sign && 
		     sym_num >= curr->atom->sym_num))) {
		prev = curr;
		curr = curr->next_lit;
		}
	    next = inst->next_lit;
	    inst->next_lit = curr;
	    if (prev == NULL)
		slits = inst;
	    else
		prev->next_lit = inst;
	    inst = next;
	    }
	c->first_lit = slits;
	}
}  /* sort lits */

/*************
 *
 *    int all_cont_cl(t, cpp) - insert containing clauses of t into *cpp
 *
 *	void in Otter, int in Penguin,as it returns TROUBLE/NO_TROUBLE.
 *
 *************/

int all_cont_cl(t, cpp)
struct term *t;
struct clause_ptr **cpp;
{
    struct rel *r;
    struct clause *c;
    struct list *l;

    if (t->type != VARIABLE && t->varnum != 0) {  /* atom */
	c = t->occ.lit->container;
	l = c->container;
	if (l == Usable || l == Sos || l == Demodulators)
	    if (insert_clause(c, cpp) == TROUBLE)
		return(TROUBLE);
	}
    else {  /* term */
	r = t->occ.rel;
	while (r != NULL) {
	    if (all_cont_cl(r->argof, cpp) == TROUBLE)
		return(TROUBLE);
	    r = r->nocc;
	    }
	}
return(NO_TROUBLE);
}  /* all_cont_cl */

/*************
 *
 *    zap_cl_list(lst)
 *
 *************/

void zap_cl_list(lst)
struct list *lst;
{
    struct clause *c1, *c2;

    c1 = lst->first_cl;
    while (c1 != NULL) {
	c2 = c1;
	c1 = c1->next_cl;
	cl_del_non(c2);
	}
    free_list(lst);
}  /* zap_cl_list */

/*************
 *
 *    mark_literal(lit)
 *
 *    Atoms have varnum > 0.  This routine inserts the appropriate code.
 *
 *************/

void mark_literal(lit)
struct literal *lit;
{
    char *name;
    struct term *a;

    a = lit->atom;
    /* atoms have varnum > 0 */
    name = sn_to_str(a->sym_num);

    if (initial_str("$ANS", name) || initial_str("$Ans", name) ||
				     initial_str("$ans", name))
	a->varnum = ANSWER;  /* answer literal */

    else if (sn_to_arity(a->sym_num) == 2 &&
			      (initial_str("EQ", name) ||
			       initial_str("Eq", name) ||
			       initial_str("eq", name) ||
			       a->sym_num == Eq_sym_num) )
	if (lit->sign)
	    a->varnum = POS_EQ;  /* positive equality */
	else
	    a->varnum = NEG_EQ;  /* negative equality */

    else if (a->sym_num == Conditional_demodulator_sym_num)
	a->varnum = CONDITIONAL_DEMOD;

    else if (name[0] == '$')
	a->varnum = EVALUABLE;  /* $ID, $LE, $AND, ... */

    else
	a->varnum = NORM_ATOM;  /* normal atom */

}  /* mark_literal */

/*************
 *
 *    int get_ancestors(c, cpp)
 *
 *	void in Otter, int Penguin, as it returns TROUBLE/NO_TROUBLE.
 *
 *************/

int get_ancestors(c, cpp)
struct clause *c;
struct clause_ptr **cpp;
{
    struct clause_ptr *cp1, *cp2, *cp3;
    struct int_ptr *ip;
    struct clause *d;

    cp1 = *cpp;
    cp3 = NULL;
    while (cp1 != NULL && cp1->c->id < c->id) {
	cp3 = cp1;
	cp1 = cp1->next;
	}
    if (cp1 == NULL || cp1->c->id > c->id) {
	if (get_clause_ptr(&cp2) == TROUBLE)
		return(TROUBLE);
	cp2->c = c;
	if (cp3 == NULL) {
	    cp2->next = *cpp;
	    *cpp = cp2;
	    }
	else {
	    cp2->next = cp3->next;
	    cp3->next = cp2;
	    }
	ip = c->parents;
	while (ip != NULL) {
	    if (ip->i >= 0) {  /* < 0 means it's a code for an inference rule */
		d = cl_find(ip->i);
		if (d == NULL)
fprintf(Fdout,"WARNING, clause %d has been deleted, proof is incomplete.\n", ip->i);
		else
		    if (get_ancestors(d, cpp) == TROUBLE)
			return(TROUBLE);
		}
	    ip = ip->next;
	    }
	}
return(NO_TROUBLE);
}  /* get_ancestors */

/*************
 *
 *    int proof_level(c)
 *
 *************/

int proof_level(c)
struct clause *c;
{
    struct int_ptr *ip;
    int id, max, l;
    struct clause *parent;
    
    if (c->parents == NULL)
        return(0);
    else {
	max = 0;
	for (ip = c->parents; ip != NULL; ip = ip->next) {
	    id = ip->i;
	    if (id > 0) {
		parent = cl_find(id);
		if (parent == NULL)
		    max = MAX_INT / 2;
		else {
		    l = proof_level(parent);
		    max = (l > max ? l : max);
		    }
		}
	    }
	return(max + 1);
	}
}  /* proof_level */

/*************
 *
 *    int renumber_vars(c)
 *
 *        Renumber the variables of a clause, starting with 0.  `c' must
 *    be nonintegrated.  return(0) if more than MAXVARS distinct variables.
 *
 *************/

int renumber_vars(c)
struct clause *c;
{
    struct literal *lit;
    int varnums[MAX_VARS];
    int i, ok;
    
    CLOCK_START(RENUMBER_TIME)

    ok = 1;
    for (i = 0; i < MAX_VARS; i++)
	varnums[i] = -1;
    
    lit = c->first_lit;
    while (lit != NULL) {
	if (renum_vars_term(lit->atom, varnums) == 0)
	    ok = 0;
	lit = lit->next_lit;
	}

    CLOCK_STOP(RENUMBER_TIME)

    return(ok);

}  /* renumber_vars */

/*************
 *
 *    int renum_vars_term(term, varnums) -- called from renumber_vars.
 *
 *************/

int renum_vars_term(t, varnums)
struct term *t;
int varnums[];
{
    struct rel *r;
    int i, ok;
    
    if (t->type == NAME)
	return(1);
    else if (t->type == COMPLEX) {
	ok = 1;
	r = t->farg;
	while (r != NULL) {
	    if (renum_vars_term(r->argval, varnums) == 0)
		ok = 0;
	    r = r->narg;
	    }
	return(ok);
	}
    else {
	i = 0;
	while (i < MAX_VARS && varnums[i] != -1 && varnums[i] != t->varnum)
	i++;
	if (i == MAX_VARS)
	    return(0);
	else {
	    if (varnums[i] == -1) {
		varnums[i] = t->varnum;
		t->varnum = i;
		}
	    else
		t->varnum = i;
	    return(1);
	    }
	}
}  /* renum_vars_term */

/*************
 *
 *    clear_var_names(t) -- set sym_num field of all variables to NULL
 *
 *************/

void clear_var_names(t)
     struct term *t;
{
    struct rel *r;
    
    if (t->type == VARIABLE)
	t->sym_num = 0;
    else {
	for (r = t->farg; r != NULL; r = r->narg)
	    clear_var_names(r->argval);
	}
}  /* clear_var_names */

/*************
 *
 *    cl_clear_vars(c)
 *
 *************/

void cl_clear_vars(c)
struct clause *c;
{
    struct literal *lit;

    for (lit = c->first_lit; lit != NULL; lit = lit->next_lit)
	clear_var_names(lit->atom);
}

/*************
 *
 *    void distinct_vars_rec(t, a)
 *
 *************/

void distinct_vars_rec(t, a)
struct term *t;
int a[];
{
    struct rel *r;
    
    if (t->type == VARIABLE)
	a[t->varnum]++;
    else if (t->type == COMPLEX)
	for (r = t->farg; r; r = r->narg)
	    distinct_vars_rec(r->argval, a);
}  /* distinct_vars_rec */

/*************
 *
 *    int distinct_vars(c)
 *
 *************/

int distinct_vars(c)
struct clause *c;
{
    struct literal *lit;
    int a[MAX_VARS], i, j;

    for (i = 0; i < MAX_VARS; i++)
	a[i] = 0;

    for (lit = c->first_lit; lit; lit = lit->next_lit)
	distinct_vars_rec(lit->atom, a);

    for (i = j = 0; i < MAX_VARS; i++)
	if (a[i] != 0)
	    j++;

    return(j);

}  /* distinct_vars */

 /*************
 *
 *    struct clause *find_first_cl(l)
 *
 *************/

struct clause *find_first_cl(l)
struct list *l;
{
    struct clause *c;

    if (l->first_cl == NULL)
	return(NULL);
    else {
	c = l->first_cl;
	return(c);
	}
}  /* find_first_cl */

/*************
 *
 *    struct clause *find_last_cl(l)
 *
 *************/

struct clause *find_last_cl(l)
struct list *l;
{
    struct clause *c;

    if (l->last_cl == NULL)
	return(NULL);
    else {
	c = l->last_cl;
	return(c);
	}
}  /* find_last_cl */

/*************
 *
 *    int find_random_cl(l,fcl)
 *
 *	Penguin: function has been modified to keep into account that l
 *	may not be Sos.
 *	struct clause * in Otter, int in Penguin, as it returns TROUBLE/
 *	NO_TROUBLE. It returns the pointer to struct clause through the
 *	parameter fcl.
 *
 *************/

int find_random_cl(l,fcl)
struct list *l;
struct clause **fcl;
{
    struct clause *c;
    int i, j;

	*fcl = NULL;				/* default */
    if (l->first_cl == NULL)
	return(NO_TROUBLE);
    else {
	if (l == Usable)
	j = (rand() % Stats[USABLE_SIZE]) + 1;
	if (l == Passive)
	j = (rand() % Stats[PASSIVE_SIZE]) + 1;
	if (l == Demodulators)
	j = (rand() % Stats[DEMODULATORS_SIZE]) + 1;
	else if (l == Inbound_msgs)
	j = (rand() % Stats[INBOUND_MSGS_SIZE]) + 1;
	else if (l == Outbound_msgs)
	j = (rand() % Stats[OUTBOUND_MSGS_SIZE]) + 1;
	else if (l == Sos)
	j = (rand() % Stats[SOS_SIZE]) + 1;
        c = l->first_cl;
	i = 1;
        while (i < j && c) {
	    c = c->next_cl;
	    i++;
	    }
	if (!c) {
	    output_stats(Fdout, 4);
	    fprintf(Fderr, "ABEND, find_random_cl, %s bad.\007\n",l->name);
	    fprintf(Fdout, "ABEND, find_random_cl, %s bad.",l->name);
	    return(TROUBLE);
	    }
	*fcl = c;
	return(NO_TROUBLE);
	}
}  /* find_random_cl */

/*************
 *
 *    struct clause *find_lightest_cl(l)
 *
 *    Input sos clauses might have weight field set to -MAX_INT so that
 *    they are returned first (in order).
 *
 *************/

struct clause *find_lightest_cl(l)
struct list *l;
{
    struct clause *c, *cm;
    int w, wm;

    if (l->first_cl == NULL)
	return(NULL);
    else {
	cm = l->first_cl;
	wm = cm->weight;
	c = cm->next_cl;
	while (c != NULL) {
	    w = c->weight;
	    if (w < wm) {
		wm = w;
		cm = c;
		}
	    c = c->next_cl;
	    }

	return(cm);
	}
}  /* find_lightest_cl */

/*************
 *
 *    struct clause *find_lightest_with_p(l,p)	Penguin only
 *
 *	Find lightest with property p:
 *	if p == 1: find lightest resident,
 *	if p == 0: find lightest non-resident.
 *
 *************/

struct clause *find_lightest_with_p(l,p)
struct list *l;
int p;
{
    struct clause *c, *cm;
    int w, wm;

    if (l->first_cl == NULL)
	return(NULL);
    else {
	cm = l->first_cl;
while (cm!=NULL && (p!=1 || cm->pid!=Whoami) && (p!=0 || cm->pid==Whoami))
	cm = cm->next_cl;
if (cm == NULL)
	return(NULL);
	wm = cm->weight;
	c = cm->next_cl;
	while (c != NULL) {
if ((p == 1 && c->pid == Whoami) || (p == 0 && c->pid != Whoami))
		{
	    w = c->weight;
	    if (w < wm) {
		wm = w;
		cm = c;
		}
		}
	    c = c->next_cl;
	    }

	return(cm);
	}
}  /* find_lightest_with_p() */

/*************
 *
 *    struct clause *find_d_light_cl(l)	 Penguin only 
 *
 *************/

struct clause *find_d_light_cl(l)
struct list *l;
{
    struct clause *c1, *c2;
    int w;

    if (l->first_cl == NULL)
	return(NULL);
    else {
	c1 = find_lightest_with_p(l,1);	/* find lightest resident */
	c2 = find_lightest_with_p(l,0);	/* find lightest non-resident */
if (c1 == NULL)
	return(c2);
else if (c2 == NULL)
	return(c1);
else
if (c1->lid < c2->lid)
	return(c1);
else if (c2->lid < c1->lid)
	return(c2);
else { /* c1->lid == c2->lid */
	w = (c2->id) / No_of_nodes;
	if (c1->id < w)
		return(c1);
	else if (w < c1->id)
		return(c2);
	else return(c2);	/* in case of tie give preference to visitor */
	}
	}
}  /* find_d_light_cl() */

/*************
 *
 *    struct clause *find_first_cl_mod_nop(l)	 Penguin only 
 *
 *	Find the first clause based on the lexicographic combination of the
 *	ordering on integers applied to bt's, lid's and id's.
 *	If a clause belongs to another Penguin,
 *	the id is divided by No_of_nodes.
 *	This should compensate for the fact that clauses coming from other
 *	Penguins get an id much higher than at the time when they were
 *	generated, because of the communication delay.
 *
 *************/

struct clause *find_first_cl_mod_nop(l)
struct list *l;
{
    struct clause *c, *cm;
    int w, wm, li, mli, mbt, b;

    if (l->first_cl == NULL)
	return(NULL);
    else {
	cm = l->first_cl;
	mli = cm->lid;
	mbt = cm->bt;
	if (cm->pid == Whoami)
		wm = cm->id;
	else wm = (cm->id) / No_of_nodes;
	c = cm->next_cl;
	while (c != NULL) {
	li = c->lid;
	b = c->bt;
	if (c->pid == Whoami)
		w = c->id;
	else w = (c->id) / No_of_nodes;
if (b < mbt || (b == mbt && (li < mli || (li == mli && w < wm))))
		{
		wm = w;
		mli = li;
		cm = c;
		}
	    c = c->next_cl;
	    }

	return(cm);
	}
}  /* find_first_cl_mod_nop() */

/*************
 *
 *    int find_given_clause(lst,fcl)
 *
 *	Penguin: function has been modified wrt. Otter, in order
 *	to apply to any list, not just to Sos.
 *	Penguin: it also adds the flags SOS_QUEUE_MOD and SOS_D_LIGHT,
 *	see cos.h for the definition.
 *	struct clause * in Otter, int in Penguin, as it returns TROUBLE/
 *	NO_TROUBLE. It returns the pointer to struct clause through the
 *	parameter fcl.
 *
 *************/

int find_given_clause(lst,fcl)
	struct list *lst;
	struct clause **fcl;
{
    struct clause *giv_cl;

    if (Parms[PICK_GIVEN_RATIO].val != -1) {
	if (Stats[CL_GIVEN] % (Parms[PICK_GIVEN_RATIO].val + 1) == 0)
	    giv_cl = find_first_cl(lst);
        else
	    giv_cl = find_lightest_cl(lst);
	}
    else if (Parms[RANDOM_RATIO].val != -1) {
	if (Stats[CL_GIVEN] % (Parms[RANDOM_RATIO].val + 1) == 0)
	{
	    if (find_random_cl(lst,&giv_cl) == TROUBLE)
		return(TROUBLE);
	}
        else
	    giv_cl = find_lightest_cl(lst);
	}
    else if (lst == Sos && Flags[SOS_QUEUE].val == 1)
	giv_cl = find_first_cl(lst);
    else if (lst == Sos && Flags[SOS_STACK].val == 1)
	giv_cl = find_last_cl(lst);
    else if (lst == Sos && Flags[SOS_QUEUE_MOD].val == 1)
	giv_cl = find_first_cl_mod_nop(lst);
    else if (lst == Sos && Flags[SOS_D_LIGHT].val == 1)
	giv_cl = find_d_light_cl(lst);
    else
	giv_cl = find_lightest_cl(lst);		/* This is the default. */

	*fcl = giv_cl;
    return(NO_TROUBLE);
}  /* find_given_clause */

/*************
 *
 *    int extract_given_clause(lst,fcl)
 *
 *	Penguin: function has been modified wrt. Otter, in order
 *	to apply to any list, not just to Sos.
 *	struct clause * in Otter, int in Penguin, as it returns TROUBLE/
 *	NO_TROUBLE. It returns the pointer to struct clause through the
 *	parameter fcl.
 *
 *************/

int extract_given_clause(lst,fcl)
	struct list *lst;
	struct clause **fcl;
{
    struct clause *giv_cl;

	*fcl = NULL;				/* default */
    if (find_given_clause(lst,&giv_cl) == TROUBLE)
		return(TROUBLE);
    if (giv_cl) {
	if (lst == Sos)
	Stats[SOS_SIZE]--;
	else if (lst == Usable)
	Stats[USABLE_SIZE]--;
	else if (lst == Inbound_msgs)
	Stats[INBOUND_MSGS_SIZE]--;
	else if (lst == Outbound_msgs)
	Stats[OUTBOUND_MSGS_SIZE]--;
	else if (lst == Passive)
	Stats[PASSIVE_SIZE]--;
	else if (lst == Demodulators)
	Stats[DEMODULATORS_SIZE]--;
	rem_from_list(giv_cl);
	}
	*fcl = giv_cl;
    	return(NO_TROUBLE);
}  /* extract_given_clause */

/*************
 *
 *    struct clause *find_given_msg(lst)	Penguin only
 *
 *************/

struct clause *find_given_msg(lst)
	struct list *lst;
{
    struct clause *giv_cl;

if (lst == Inbound_msgs)
{
    if (Flags[IN_MSG_QUEUE].val)
	giv_cl = find_first_cl(lst);
    else if (Flags[IN_MSG_STACK].val)
	giv_cl = find_last_cl(lst);
    else
	giv_cl = find_lightest_cl(lst);
}
else if (lst == Outbound_msgs)
{
    if (Flags[OUT_MSG_QUEUE].val)
	giv_cl = find_first_cl(lst);
    else if (Flags[OUT_MSG_STACK].val)
	giv_cl = find_last_cl(lst);
    else
	giv_cl = find_lightest_cl(lst);
}

    return(giv_cl);
}  /* find_given_msg() */

/*************
 *
 *    struct clause *extract_given_msg(lst)		Penguin only
 *
 *************/

struct clause *extract_given_msg(lst)
	struct list *lst;
{
    struct clause *giv_cl;

    giv_cl = find_given_msg(lst);
    if (giv_cl)
	{
	if (lst == Inbound_msgs)
	Stats[INBOUND_MSGS_SIZE]--;
	else if (lst == Outbound_msgs)
	Stats[OUTBOUND_MSGS_SIZE]--;
	rem_from_list(giv_cl);
	}
    return(giv_cl);
}  /* extract_given_msg */

/*************
 *
 *    int unit_del(c, udri)  --  unit deletion
 *
 *    Return 1 if any deletions occur.
 *	Penguin: it returns TROUBLE/NO_TROUBLE, 0/1 through the 
 *	parameter udri.
 *
 *************/

int unit_del(c, udri)
struct clause *c;
int *udri;
{
    struct clause *d;
    struct literal *prev, *curr, *next, *answers, *l1, *l2;
    struct term *d_atom;
    struct context *s;
    struct is_tree *is_db;
    struct fsub_pos *pos;
    struct int_ptr *ip0, *ip, *lp;
    int deleted, return_val;
	struct term *tempatom;

	*udri = 0;				/* default */
    return_val = 0;
    if (get_context(&s) == TROUBLE)
	return(TROUBLE);

    /* first get last parent */
    lp = c->parents;
    if (lp != NULL)
	while (lp->next != NULL)
	    lp = lp->next;
    
    ip0 = lp;  /* save position to insert "ud" if any deleted */

    answers = NULL;
    prev = NULL;
    next = c->first_lit;
    while (next != NULL) {
	curr = next;
	next = next->next_lit;
	is_db = curr->sign ? Is_neg_lits : Is_pos_lits;
	if (fs_retrieve(curr->atom, s, is_db, &pos, &d_atom) == TROUBLE)
		return(TROUBLE);
	deleted = 0;
	while (d_atom != NULL && deleted == 0) {
	    d = d_atom->occ.lit->container;
	    if (num_literals(d) == 1) {
		return_val = 1;
		if (prev == NULL)
		    c->first_lit = next;
		else
		    prev->next_lit = next;
		if (get_int_ptr(&ip) == TROUBLE)
			return(TROUBLE);
		 /* append to history */
		ip->i = d->id;
		if (lp == NULL)
		    c->parents = ip;
		else
		    lp->next = ip;
		lp = ip;

		l2 = d->first_lit;  /* now append any answer literals */
		while (l2 != NULL) {
		    if (l2->atom->varnum == ANSWER) {
			if (get_literal(&l1) == TROUBLE)
				return(TROUBLE);
			l1->container = c;
			l1->sign = l2->sign;
			if (apply(l2->atom, s, &tempatom) == TROUBLE)
				return(TROUBLE);
			l1->atom = tempatom;
			l1->atom->varnum = ANSWER;
			l1->atom->occ.lit = l1;
			l1->next_lit = answers;
			answers = l1;
			}
		    l2 = l2->next_lit;
		    }

		curr->atom->occ.lit = NULL;  /* so zap_term won't complain */
		zap_term(curr->atom);
		free_literal(curr);

		canc_fs_pos(pos, s);
		Stats[UNIT_DELETES]++;
		deleted = 1;
		}
	    else
if (fs_retrieve((struct term *) NULL, s, is_db, &pos, &d_atom) == TROUBLE)
		return(TROUBLE);
	    }
	if (deleted == 0)
	    prev = curr;
	}
    if (prev == NULL)
	c->first_lit = answers;
    else
	prev->next_lit = answers;
    if (lp != ip0) {  /* at least one deletion occurred */
	if (get_int_ptr(&ip) == TROUBLE)
		return(TROUBLE);
	ip->i = UNIT_DEL_RULE;
	if (ip0 == NULL) {
	    ip->next = c->parents;
	    c->parents = ip;
	    }
	else {
	    ip->next = ip0->next;
	    ip0->next = ip;
	    }
	}
    free_context(s);
    *udri = return_val;
	return(NO_TROUBLE);
}  /* unit_del */

/*************
 *
 *    int n_resolution_check(c)
 *
 *    Return 1 if c satisfies the n-resolution restriction.
 *    c satisfies the restriction iff 
 *         1. c was not inferred by binary resolution, or
 *         2. one parent is a positive unit, or
 *         3. one parent is a negative clause.
 *
 *************/

int n_resolution_check(c)
struct clause *c;
{
    struct int_ptr *ip;
    struct clause *parent;

    if (c->parents == NULL || c->parents->i != BINARY_RES_RULE)
	return(1);  /* not generated by binary resolution */
    else {
	ip = c->parents->next;
        parent = cl_find(ip->i);
        if (pos_clause(parent) && num_literals(parent) == 1)
	    return(1);
	else if (neg_clause(parent))
	    return(1);
	else {
	    ip = ip->next;
	    parent = cl_find(ip->i);
	    if (pos_clause(parent) && num_literals(parent) == 1)
		return(1);
	    else if (neg_clause(parent))
		return(1);
	    else
		return(0);
	    }
	}
}  /* n_resolution_check  */

